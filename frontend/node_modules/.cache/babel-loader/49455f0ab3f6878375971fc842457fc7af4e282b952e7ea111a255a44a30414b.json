{"ast":null,"code":"/**\n *  A **FallbackProvider** provides resilience, security and performance\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport { assert, assertArgument, getBigInt, getNumber, isError } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction stringify(value) {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === \"bigint\") {\n      return {\n        type: \"bigint\",\n        value: value.toString()\n      };\n    }\n    return value;\n  });\n}\n;\nconst defaultConfig = {\n  stallTimeout: 400,\n  priority: 1,\n  weight: 1\n};\nconst defaultState = {\n  blockNumber: -2,\n  requests: 0,\n  lateResponses: 0,\n  errorResponses: 0,\n  outOfSync: -1,\n  unsupportedEvents: 0,\n  rollingDuration: 0,\n  score: 0,\n  _network: null,\n  _updateNumber: null,\n  _totalTime: 0,\n  _lastFatalError: null,\n  _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n    if (!config._updateNumber) {\n      config._updateNumber = (async () => {\n        try {\n          const blockNumber = await config.provider.getBlockNumber();\n          if (blockNumber > config.blockNumber) {\n            config.blockNumber = blockNumber;\n          }\n        } catch (error) {\n          config.blockNumber = -2;\n          config._lastFatalError = error;\n          config._lastFatalErrorTimestamp = getTime();\n        }\n        config._updateNumber = null;\n      })();\n    }\n    await config._updateNumber;\n    config.outOfSync++;\n    if (config._lastFatalError) {\n      break;\n    }\n  }\n}\nfunction _normalize(value) {\n  if (value == null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(_normalize).join(\",\") + \"]\";\n  }\n  if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n    return _normalize(value.toJSON());\n  }\n  switch (typeof value) {\n    case \"boolean\":\n    case \"symbol\":\n      return value.toString();\n    case \"bigint\":\n    case \"number\":\n      return BigInt(value).toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"object\":\n      {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(k => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n      }\n  }\n  console.log(\"Could not serialize\", value);\n  throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(method, value) {\n  if (\"error\" in value) {\n    const error = value.error;\n    let tag;\n    if (isError(error, \"CALL_EXCEPTION\")) {\n      tag = _normalize(Object.assign({}, error, {\n        shortMessage: undefined,\n        reason: undefined,\n        info: undefined\n      }));\n    } else {\n      tag = _normalize(error);\n    }\n    return {\n      tag,\n      value: error\n    };\n  }\n  const result = value.result;\n  return {\n    tag: _normalize(result),\n    value: result\n  };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n  const tally = new Map();\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    const t = tally.get(tag) || {\n      value,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(tag, t);\n  }\n  let best = null;\n  for (const r of tally.values()) {\n    if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n      best = r;\n    }\n  }\n  if (best) {\n    return best.value;\n  }\n  return undefined;\n}\nfunction getMedian(quorum, results) {\n  let resultWeight = 0;\n  const errorMap = new Map();\n  let bestError = null;\n  const values = [];\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    if (value instanceof Error) {\n      const e = errorMap.get(tag) || {\n        value,\n        weight: 0\n      };\n      e.weight += weight;\n      errorMap.set(tag, e);\n      if (bestError == null || e.weight > bestError.weight) {\n        bestError = e;\n      }\n    } else {\n      values.push(BigInt(value));\n      resultWeight += weight;\n    }\n  }\n  if (resultWeight < quorum) {\n    // We have quorum for an error\n    if (bestError && bestError.weight >= quorum) {\n      return bestError.value;\n    }\n    // We do not have quorum for a result\n    return undefined;\n  }\n  // Get the sorted values\n  values.sort((a, b) => a < b ? -1 : b > a ? 1 : 0);\n  const mid = Math.floor(values.length / 2);\n  // Odd-length; take the middle value\n  if (values.length % 2) {\n    return values[mid];\n  }\n  // Even length; take the ceiling of the mean of the center two values\n  return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n  // If any value or error meets quorum, that is our preferred result\n  const result = checkQuorum(quorum, results);\n  if (result !== undefined) {\n    return result;\n  }\n  // Otherwise, do we have any result?\n  for (const r of results) {\n    if (r.value) {\n      return r.value;\n    }\n  }\n  // Nope!\n  return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n  if (quorum === 1) {\n    return getNumber(getMedian(quorum, results), \"%internal\");\n  }\n  const tally = new Map();\n  const add = (result, weight) => {\n    const t = tally.get(result) || {\n      result,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(result, t);\n  };\n  for (const {\n    weight,\n    value\n  } of results) {\n    const r = getNumber(value);\n    add(r - 1, weight);\n    add(r, weight);\n    add(r + 1, weight);\n  }\n  let bestWeight = 0;\n  let bestResult = undefined;\n  for (const {\n    weight,\n    result\n  } of tally.values()) {\n    // Use this result, if this result meets quorum and has either:\n    // - a better weight\n    // - or equal weight, but the result is larger\n    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {\n      bestWeight = weight;\n      bestResult = result;\n    }\n  }\n  return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resilience by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nexport class FallbackProvider extends AbstractProvider {\n  /**\n   *  The number of backends that must agree on a value before it is\n   *  accpeted.\n   */\n  quorum;\n  /**\n   *  @_ignore:\n   */\n  eventQuorum;\n  /**\n   *  @_ignore:\n   */\n  eventWorkers;\n  #configs;\n  #height;\n  #initialSyncPromise;\n  /**\n   *  Creates a new **FallbackProvider** with %%providers%% connected to\n   *  %%network%%.\n   *\n   *  If a [[Provider]] is included in %%providers%%, defaults are used\n   *  for the configuration.\n   */\n  constructor(providers, network, options) {\n    super(network, options);\n    this.#configs = providers.map(p => {\n      if (p instanceof AbstractProvider) {\n        return Object.assign({\n          provider: p\n        }, defaultConfig, defaultState);\n      } else {\n        return Object.assign({}, defaultConfig, p, defaultState);\n      }\n    });\n    this.#height = -2;\n    this.#initialSyncPromise = null;\n    if (options && options.quorum != null) {\n      this.quorum = options.quorum;\n    } else {\n      this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\n        accum += config.weight;\n        return accum;\n      }, 0) / 2);\n    }\n    this.eventQuorum = 1;\n    this.eventWorkers = 1;\n    assertArgument(this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0), \"quorum exceed provider weight\", \"quorum\", this.quorum);\n  }\n  get providerConfigs() {\n    return this.#configs.map(c => {\n      const result = Object.assign({}, c);\n      for (const key in result) {\n        if (key[0] === \"_\") {\n          delete result[key];\n        }\n      }\n      return result;\n    });\n  }\n  async _detectNetwork() {\n    return Network.from(getBigInt(await this._perform({\n      method: \"chainId\"\n    })));\n  }\n  // @TODO: Add support to select providers to be the event subscriber\n  //_getSubscriber(sub: Subscription): Subscriber {\n  //    throw new Error(\"@TODO\");\n  //}\n  /**\n   *  Transforms a %%req%% into the correct method call on %%provider%%.\n   */\n  async _translatePerform(provider, req) {\n    switch (req.method) {\n      case \"broadcastTransaction\":\n        return await provider.broadcastTransaction(req.signedTransaction);\n      case \"call\":\n        return await provider.call(Object.assign({}, req.transaction, {\n          blockTag: req.blockTag\n        }));\n      case \"chainId\":\n        return (await provider.getNetwork()).chainId;\n      case \"estimateGas\":\n        return await provider.estimateGas(req.transaction);\n      case \"getBalance\":\n        return await provider.getBalance(req.address, req.blockTag);\n      case \"getBlock\":\n        {\n          const block = \"blockHash\" in req ? req.blockHash : req.blockTag;\n          return await provider.getBlock(block, req.includeTransactions);\n        }\n      case \"getBlockNumber\":\n        return await provider.getBlockNumber();\n      case \"getCode\":\n        return await provider.getCode(req.address, req.blockTag);\n      case \"getGasPrice\":\n        return (await provider.getFeeData()).gasPrice;\n      case \"getPriorityFee\":\n        return (await provider.getFeeData()).maxPriorityFeePerGas;\n      case \"getLogs\":\n        return await provider.getLogs(req.filter);\n      case \"getStorage\":\n        return await provider.getStorage(req.address, req.position, req.blockTag);\n      case \"getTransaction\":\n        return await provider.getTransaction(req.hash);\n      case \"getTransactionCount\":\n        return await provider.getTransactionCount(req.address, req.blockTag);\n      case \"getTransactionReceipt\":\n        return await provider.getTransactionReceipt(req.hash);\n      case \"getTransactionResult\":\n        return await provider.getTransactionResult(req.hash);\n    }\n  }\n  // Grab the next (random) config that is not already part of\n  // the running set\n  #getNextConfig(running) {\n    // @TODO: Maybe do a check here to favour (heavily) providers that\n    //        do not require waitForSync and disfavour providers that\n    //        seem down-ish or are behaving slowly\n    const configs = Array.from(running).map(r => r.config);\n    // Shuffle the states, sorted by priority\n    const allConfigs = this.#configs.slice();\n    shuffle(allConfigs);\n    allConfigs.sort((a, b) => a.priority - b.priority);\n    for (const config of allConfigs) {\n      if (config._lastFatalError) {\n        continue;\n      }\n      if (configs.indexOf(config) === -1) {\n        return config;\n      }\n    }\n    return null;\n  }\n  // Adds a new runner (if available) to running.\n  #addRunner(running, req) {\n    const config = this.#getNextConfig(running);\n    // No runners available\n    if (config == null) {\n      return null;\n    }\n    // Create a new runner\n    const runner = {\n      config,\n      result: null,\n      didBump: false,\n      perform: null,\n      staller: null\n    };\n    const now = getTime();\n    // Start performing this operation\n    runner.perform = (async () => {\n      try {\n        config.requests++;\n        const result = await this._translatePerform(config.provider, req);\n        runner.result = {\n          result\n        };\n      } catch (error) {\n        config.errorResponses++;\n        runner.result = {\n          error\n        };\n      }\n      const dt = getTime() - now;\n      config._totalTime += dt;\n      config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n      runner.perform = null;\n    })();\n    // Start a staller; when this times out, it's time to force\n    // kicking off another runner because we are taking too long\n    runner.staller = (async () => {\n      await stall(config.stallTimeout);\n      runner.staller = null;\n    })();\n    running.add(runner);\n    return runner;\n  }\n  // Initializes the blockNumber and network for each runner and\n  // blocks until initialized\n  async #initialSync() {\n    let initialSync = this.#initialSyncPromise;\n    if (!initialSync) {\n      const promises = [];\n      this.#configs.forEach(config => {\n        promises.push((async () => {\n          await waitForSync(config, 0);\n          if (!config._lastFatalError) {\n            config._network = await config.provider.getNetwork();\n          }\n        })());\n      });\n      this.#initialSyncPromise = initialSync = (async () => {\n        // Wait for all providers to have a block number and network\n        await Promise.all(promises);\n        // Check all the networks match\n        let chainId = null;\n        for (const config of this.#configs) {\n          if (config._lastFatalError) {\n            continue;\n          }\n          const network = config._network;\n          if (chainId == null) {\n            chainId = network.chainId;\n          } else if (network.chainId !== chainId) {\n            assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"new FallbackProvider\"\n            });\n          }\n        }\n      })();\n    }\n    await initialSync;\n  }\n  async #checkQuorum(running, req) {\n    // Get all the result objects\n    const results = [];\n    for (const runner of running) {\n      if (runner.result != null) {\n        const {\n          tag,\n          value\n        } = normalizeResult(req.method, runner.result);\n        results.push({\n          tag,\n          value,\n          weight: runner.config.weight\n        });\n      }\n    }\n    // Are there enough results to event meet quorum?\n    if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {\n      return undefined;\n    }\n    switch (req.method) {\n      case \"getBlockNumber\":\n        {\n          // We need to get the bootstrap block height\n          if (this.#height === -2) {\n            this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter(c => !c._lastFatalError).map(c => ({\n              value: c.blockNumber,\n              tag: getNumber(c.blockNumber).toString(),\n              weight: c.weight\n            })))));\n          }\n          // Find the mode across all the providers, allowing for\n          // a little drift between block heights\n          const mode = getFuzzyMode(this.quorum, results);\n          if (mode === undefined) {\n            return undefined;\n          }\n          if (mode > this.#height) {\n            this.#height = mode;\n          }\n          return this.#height;\n        }\n      case \"getGasPrice\":\n      case \"getPriorityFee\":\n      case \"estimateGas\":\n        return getMedian(this.quorum, results);\n      case \"getBlock\":\n        // Pending blocks are in the mempool and already\n        // quite untrustworthy; just grab anything\n        if (\"blockTag\" in req && req.blockTag === \"pending\") {\n          return getAnyResult(this.quorum, results);\n        }\n        return checkQuorum(this.quorum, results);\n      case \"call\":\n      case \"chainId\":\n      case \"getBalance\":\n      case \"getTransactionCount\":\n      case \"getCode\":\n      case \"getStorage\":\n      case \"getTransaction\":\n      case \"getTransactionReceipt\":\n      case \"getLogs\":\n        return checkQuorum(this.quorum, results);\n      case \"broadcastTransaction\":\n        return getAnyResult(this.quorum, results);\n    }\n    assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n      operation: `_perform(${stringify(req.method)})`\n    });\n  }\n  async #waitForQuorum(running, req) {\n    if (running.size === 0) {\n      throw new Error(\"no runners?!\");\n    }\n    // Any promises that are interesting to watch for; an expired stall\n    // or a successful perform\n    const interesting = [];\n    let newRunners = 0;\n    for (const runner of running) {\n      // No responses, yet; keep an eye on it\n      if (runner.perform) {\n        interesting.push(runner.perform);\n      }\n      // Still stalling...\n      if (runner.staller) {\n        interesting.push(runner.staller);\n        continue;\n      }\n      // This runner has already triggered another runner\n      if (runner.didBump) {\n        continue;\n      }\n      // Got a response (result or error) or stalled; kick off another runner\n      runner.didBump = true;\n      newRunners++;\n    }\n    // Check if we have reached quorum on a result (or error)\n    const value = await this.#checkQuorum(running, req);\n    if (value !== undefined) {\n      if (value instanceof Error) {\n        throw value;\n      }\n      return value;\n    }\n    // Add any new runners, because a staller timed out or a result\n    // or error response came in.\n    for (let i = 0; i < newRunners; i++) {\n      this.#addRunner(running, req);\n    }\n    // All providers have returned, and we have no result\n    assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n      request: \"%sub-requests\",\n      info: {\n        request: req,\n        results: Array.from(running).map(r => stringify(r.result))\n      }\n    });\n    // Wait for someone to either complete its perform or stall out\n    await Promise.race(interesting);\n    // This is recursive, but at worst case the depth is 2x the\n    // number of providers (each has a perform and a staller)\n    return await this.#waitForQuorum(running, req);\n  }\n  async _perform(req) {\n    // Broadcasting a transaction is rare (ish) and already incurs\n    // a cost on the user, so spamming is safe-ish. Just send it to\n    // every backend.\n    if (req.method === \"broadcastTransaction\") {\n      // Once any broadcast provides a positive result, use it. No\n      // need to wait for anyone else\n      const results = this.#configs.map(c => null);\n      const broadcasts = this.#configs.map(async ({\n        provider,\n        weight\n      }, index) => {\n        try {\n          const result = await provider._perform(req);\n          results[index] = Object.assign(normalizeResult(req.method, {\n            result\n          }), {\n            weight\n          });\n        } catch (error) {\n          results[index] = Object.assign(normalizeResult(req.method, {\n            error\n          }), {\n            weight\n          });\n        }\n      });\n      // As each promise finishes...\n      while (true) {\n        // Check for a valid broadcast result\n        const done = results.filter(r => r != null);\n        for (const {\n          value\n        } of done) {\n          if (!(value instanceof Error)) {\n            return value;\n          }\n        }\n        // Check for a legit broadcast error (one which we cannot\n        // recover from; some nodes may return the following red\n        // herring events:\n        // - alredy seend (UNKNOWN_ERROR)\n        // - NONCE_EXPIRED\n        // - REPLACEMENT_UNDERPRICED\n        const result = checkQuorum(this.quorum, results.filter(r => r != null));\n        if (isError(result, \"INSUFFICIENT_FUNDS\")) {\n          throw result;\n        }\n        // Kick off the next provider (if any)\n        const waiting = broadcasts.filter((b, i) => results[i] == null);\n        if (waiting.length === 0) {\n          break;\n        }\n        await Promise.race(waiting);\n      }\n      // Use standard quorum results; any result was returned above,\n      // so this will find any error that met quorum if any\n      const result = getAnyResult(this.quorum, results);\n      assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n        request: \"%sub-requests\",\n        info: {\n          request: req,\n          results: results.map(stringify)\n        }\n      });\n      if (result instanceof Error) {\n        throw result;\n      }\n      return result;\n    }\n    await this.#initialSync();\n    // Bootstrap enough runners to meet quorum\n    const running = new Set();\n    let inflightQuorum = 0;\n    while (true) {\n      const runner = this.#addRunner(running, req);\n      if (runner == null) {\n        break;\n      }\n      inflightQuorum += runner.config.weight;\n      if (inflightQuorum >= this.quorum) {\n        break;\n      }\n    }\n    const result = await this.#waitForQuorum(running, req);\n    // Track requests sent to a provider that are still\n    // outstanding after quorum has been otherwise found\n    for (const runner of running) {\n      if (runner.perform && runner.result == null) {\n        runner.config.lateResponses++;\n      }\n    }\n    return result;\n  }\n  async destroy() {\n    for (const {\n      provider\n    } of this.#configs) {\n      provider.destroy();\n    }\n    super.destroy();\n  }\n}","map":{"version":3,"names":["assert","assertArgument","getBigInt","getNumber","isError","AbstractProvider","Network","BN_1","BigInt","BN_2","shuffle","array","i","length","j","Math","floor","random","tmp","stall","duration","Promise","resolve","setTimeout","getTime","Date","stringify","value","JSON","key","type","toString","defaultConfig","stallTimeout","priority","weight","defaultState","blockNumber","requests","lateResponses","errorResponses","outOfSync","unsupportedEvents","rollingDuration","score","_network","_updateNumber","_totalTime","_lastFatalError","_lastFatalErrorTimestamp","waitForSync","config","provider","getBlockNumber","error","_normalize","Array","isArray","map","join","toJSON","keys","Object","sort","k","console","log","Error","normalizeResult","method","tag","assign","shortMessage","undefined","reason","info","result","checkQuorum","quorum","results","tally","Map","t","get","set","best","r","values","getMedian","resultWeight","errorMap","bestError","e","push","a","b","mid","getAnyResult","getFuzzyMode","add","bestWeight","bestResult","FallbackProvider","eventQuorum","eventWorkers","configs","height","initialSyncPromise","constructor","providers","network","options","p","ceil","reduce","accum","c","providerConfigs","_detectNetwork","from","_perform","_translatePerform","req","broadcastTransaction","signedTransaction","call","transaction","blockTag","getNetwork","chainId","estimateGas","getBalance","address","block","blockHash","getBlock","includeTransactions","getCode","getFeeData","gasPrice","maxPriorityFeePerGas","getLogs","filter","getStorage","position","getTransaction","hash","getTransactionCount","getTransactionReceipt","getTransactionResult","getNextConfig","#getNextConfig","running","allConfigs","slice","indexOf","addRunner","#addRunner","runner","didBump","perform","staller","now","dt","initialSync","#initialSync","promises","forEach","all","operation","#checkQuorum","mode","waitForQuorum","#waitForQuorum","size","interesting","newRunners","request","race","broadcasts","index","done","waiting","Set","inflightQuorum","destroy"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/providers/provider-fallback.js"],"sourcesContent":["/**\n *  A **FallbackProvider** provides resilience, security and performance\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport { assert, assertArgument, getBigInt, getNumber, isError } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction stringify(value) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof (value) === \"bigint\") {\n            return { type: \"bigint\", value: value.toString() };\n        }\n        return value;\n    });\n}\n;\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\nconst defaultState = {\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\n    _network: null, _updateNumber: null, _totalTime: 0,\n    _lastFatalError: null, _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n        if (!config._updateNumber) {\n            config._updateNumber = (async () => {\n                try {\n                    const blockNumber = await config.provider.getBlockNumber();\n                    if (blockNumber > config.blockNumber) {\n                        config.blockNumber = blockNumber;\n                    }\n                }\n                catch (error) {\n                    config.blockNumber = -2;\n                    config._lastFatalError = error;\n                    config._lastFatalErrorTimestamp = getTime();\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n        if (config._lastFatalError) {\n            break;\n        }\n    }\n}\nfunction _normalize(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return _normalize(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n        case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{\" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n        }\n    }\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(method, value) {\n    if (\"error\" in value) {\n        const error = value.error;\n        let tag;\n        if (isError(error, \"CALL_EXCEPTION\")) {\n            tag = _normalize(Object.assign({}, error, {\n                shortMessage: undefined, reason: undefined, info: undefined\n            }));\n        }\n        else {\n            tag = _normalize(error);\n        }\n        return { tag, value: error };\n    }\n    const result = value.result;\n    return { tag: _normalize(result), value: result };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n    const tally = new Map();\n    for (const { value, tag, weight } of results) {\n        const t = tally.get(tag) || { value, weight: 0 };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n    let best = null;\n    for (const r of tally.values()) {\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n    if (best) {\n        return best.value;\n    }\n    return undefined;\n}\nfunction getMedian(quorum, results) {\n    let resultWeight = 0;\n    const errorMap = new Map();\n    let bestError = null;\n    const values = [];\n    for (const { value, tag, weight } of results) {\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || { value, weight: 0 };\n            e.weight += weight;\n            errorMap.set(tag, e);\n            if (bestError == null || e.weight > bestError.weight) {\n                bestError = e;\n            }\n        }\n        else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) {\n            return bestError.value;\n        }\n        // We do not have quorum for a result\n        return undefined;\n    }\n    // Get the sorted values\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\n    const mid = Math.floor(values.length / 2);\n    // Odd-length; take the middle value\n    if (values.length % 2) {\n        return values[mid];\n    }\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) {\n        return result;\n    }\n    // Otherwise, do we have any result?\n    for (const r of results) {\n        if (r.value) {\n            return r.value;\n        }\n    }\n    // Nope!\n    return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n    if (quorum === 1) {\n        return getNumber(getMedian(quorum, results), \"%internal\");\n    }\n    const tally = new Map();\n    const add = (result, weight) => {\n        const t = tally.get(result) || { result, weight: 0 };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n    for (const { weight, value } of results) {\n        const r = getNumber(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n    let bestWeight = 0;\n    let bestResult = undefined;\n    for (const { weight, result } of tally.values()) {\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n    return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resilience by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nexport class FallbackProvider extends AbstractProvider {\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    quorum;\n    /**\n     *  @_ignore:\n     */\n    eventQuorum;\n    /**\n     *  @_ignore:\n     */\n    eventWorkers;\n    #configs;\n    #height;\n    #initialSyncPromise;\n    /**\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\n     *  %%network%%.\n     *\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\n     *  for the configuration.\n     */\n    constructor(providers, network, options) {\n        super(network, options);\n        this.#configs = providers.map((p) => {\n            if (p instanceof AbstractProvider) {\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\n            }\n            else {\n                return Object.assign({}, defaultConfig, p, defaultState);\n            }\n        });\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n        if (options && options.quorum != null) {\n            this.quorum = options.quorum;\n        }\n        else {\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\n                accum += config.weight;\n                return accum;\n            }, 0) / 2);\n        }\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n        assertArgument(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), \"quorum exceed provider weight\", \"quorum\", this.quorum);\n    }\n    get providerConfigs() {\n        return this.#configs.map((c) => {\n            const result = Object.assign({}, c);\n            for (const key in result) {\n                if (key[0] === \"_\") {\n                    delete result[key];\n                }\n            }\n            return result;\n        });\n    }\n    async _detectNetwork() {\n        return Network.from(getBigInt(await this._perform({ method: \"chainId\" })));\n    }\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n    /**\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\n     */\n    async _translatePerform(provider, req) {\n        switch (req.method) {\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\": {\n                const block = (\"blockHash\" in req) ? req.blockHash : req.blockTag;\n                return await provider.getBlock(block, req.includeTransactions);\n            }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getPriorityFee\":\n                return (await provider.getFeeData()).maxPriorityFeePerGas;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running) {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n        const configs = Array.from(running).map((r) => r.config);\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b) => (a.priority - b.priority));\n        for (const config of allConfigs) {\n            if (config._lastFatalError) {\n                continue;\n            }\n            if (configs.indexOf(config) === -1) {\n                return config;\n            }\n        }\n        return null;\n    }\n    // Adds a new runner (if available) to running.\n    #addRunner(running, req) {\n        const config = this.#getNextConfig(running);\n        // No runners available\n        if (config == null) {\n            return null;\n        }\n        // Create a new runner\n        const runner = {\n            config, result: null, didBump: false,\n            perform: null, staller: null\n        };\n        const now = getTime();\n        // Start performing this operation\n        runner.perform = (async () => {\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = { result };\n            }\n            catch (error) {\n                config.errorResponses++;\n                runner.result = { error };\n            }\n            const dt = (getTime() - now);\n            config._totalTime += dt;\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n            runner.perform = null;\n        })();\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async () => {\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n        running.add(runner);\n        return runner;\n    }\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync() {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises = [];\n            this.#configs.forEach((config) => {\n                promises.push((async () => {\n                    await waitForSync(config, 0);\n                    if (!config._lastFatalError) {\n                        config._network = await config.provider.getNetwork();\n                    }\n                })());\n            });\n            this.#initialSyncPromise = initialSync = (async () => {\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n                // Check all the networks match\n                let chainId = null;\n                for (const config of this.#configs) {\n                    if (config._lastFatalError) {\n                        continue;\n                    }\n                    const network = (config._network);\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    }\n                    else if (network.chainId !== chainId) {\n                        assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n        await initialSync;\n    }\n    async #checkQuorum(running, req) {\n        // Get all the result objects\n        const results = [];\n        for (const runner of running) {\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(req.method, runner.result);\n                results.push({ tag, value, weight: runner.config.weight });\n            }\n        }\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\n            return undefined;\n        }\n        switch (req.method) {\n            case \"getBlockNumber\": {\n                // We need to get the bootstrap block height\n                if (this.#height === -2) {\n                    this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({\n                        value: c.blockNumber,\n                        tag: getNumber(c.blockNumber).toString(),\n                        weight: c.weight\n                    })))));\n                }\n                // Find the mode across all the providers, allowing for\n                // a little drift between block heights\n                const mode = getFuzzyMode(this.quorum, results);\n                if (mode === undefined) {\n                    return undefined;\n                }\n                if (mode > this.#height) {\n                    this.#height = mode;\n                }\n                return this.#height;\n            }\n            case \"getGasPrice\":\n            case \"getPriorityFee\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n        assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${stringify(req.method)})`\n        });\n    }\n    async #waitForQuorum(running, req) {\n        if (running.size === 0) {\n            throw new Error(\"no runners?!\");\n        }\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting = [];\n        let newRunners = 0;\n        for (const runner of running) {\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n            // This runner has already triggered another runner\n            if (runner.didBump) {\n                continue;\n            }\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) {\n                throw value;\n            }\n            return value;\n        }\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for (let i = 0; i < newRunners; i++) {\n            this.#addRunner(running, req);\n        }\n        // All providers have returned, and we have no result\n        assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\n        });\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n    async _perform(req) {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            // Once any broadcast provides a positive result, use it. No\n            // need to wait for anyone else\n            const results = this.#configs.map((c) => null);\n            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {\n                try {\n                    const result = await provider._perform(req);\n                    results[index] = Object.assign(normalizeResult(req.method, { result }), { weight });\n                }\n                catch (error) {\n                    results[index] = Object.assign(normalizeResult(req.method, { error }), { weight });\n                }\n            });\n            // As each promise finishes...\n            while (true) {\n                // Check for a valid broadcast result\n                const done = results.filter((r) => (r != null));\n                for (const { value } of done) {\n                    if (!(value instanceof Error)) {\n                        return value;\n                    }\n                }\n                // Check for a legit broadcast error (one which we cannot\n                // recover from; some nodes may return the following red\n                // herring events:\n                // - alredy seend (UNKNOWN_ERROR)\n                // - NONCE_EXPIRED\n                // - REPLACEMENT_UNDERPRICED\n                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));\n                if (isError(result, \"INSUFFICIENT_FUNDS\")) {\n                    throw result;\n                }\n                // Kick off the next provider (if any)\n                const waiting = broadcasts.filter((b, i) => (results[i] == null));\n                if (waiting.length === 0) {\n                    break;\n                }\n                await Promise.race(waiting);\n            }\n            // Use standard quorum results; any result was returned above,\n            // so this will find any error that met quorum if any\n            const result = getAnyResult(this.quorum, results);\n            assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: { request: req, results: results.map(stringify) }\n            });\n            if (result instanceof Error) {\n                throw result;\n            }\n            return result;\n        }\n        await this.#initialSync();\n        // Bootstrap enough runners to meet quorum\n        const running = new Set();\n        let inflightQuorum = 0;\n        while (true) {\n            const runner = this.#addRunner(running, req);\n            if (runner == null) {\n                break;\n            }\n            inflightQuorum += runner.config.weight;\n            if (inflightQuorum >= this.quorum) {\n                break;\n            }\n        }\n        const result = await this.#waitForQuorum(running, req);\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running) {\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n        return result;\n    }\n    async destroy() {\n        for (const { provider } of this.#configs) {\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-fallback.js.map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,EAAEC,cAAc,EAAEC,SAAS,EAAEC,SAAS,EAAEC,OAAO,QAAQ,mBAAmB;AACzF,SAASC,gBAAgB,QAAQ,wBAAwB;AACzD,SAASC,OAAO,QAAQ,cAAc;AACtC,MAAMC,IAAI,GAAGC,MAAM,CAAC,GAAG,CAAC;AACxB,MAAMC,IAAI,GAAGD,MAAM,CAAC,GAAG,CAAC;AACxB,SAASE,OAAOA,CAACC,KAAK,EAAE;EACpB,KAAK,IAAIC,CAAC,GAAGD,KAAK,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACvC,MAAME,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,MAAMM,GAAG,GAAGP,KAAK,CAACC,CAAC,CAAC;IACpBD,KAAK,CAACC,CAAC,CAAC,GAAGD,KAAK,CAACG,CAAC,CAAC;IACnBH,KAAK,CAACG,CAAC,CAAC,GAAGI,GAAG;EAClB;AACJ;AACA,SAASC,KAAKA,CAACC,QAAQ,EAAE;EACrB,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;IAAEC,UAAU,CAACD,OAAO,EAAEF,QAAQ,CAAC;EAAE,CAAC,CAAC;AACvE;AACA,SAASI,OAAOA,CAAA,EAAG;EAAE,OAAQ,IAAIC,IAAI,CAAC,CAAC,CAAED,OAAO,CAAC,CAAC;AAAE;AACpD,SAASE,SAASA,CAACC,KAAK,EAAE;EACtB,OAAOC,IAAI,CAACF,SAAS,CAACC,KAAK,EAAE,CAACE,GAAG,EAAEF,KAAK,KAAK;IACzC,IAAI,OAAQA,KAAM,KAAK,QAAQ,EAAE;MAC7B,OAAO;QAAEG,IAAI,EAAE,QAAQ;QAAEH,KAAK,EAAEA,KAAK,CAACI,QAAQ,CAAC;MAAE,CAAC;IACtD;IACA,OAAOJ,KAAK;EAChB,CAAC,CAAC;AACN;AACA;AACA,MAAMK,aAAa,GAAG;EAAEC,YAAY,EAAE,GAAG;EAAEC,QAAQ,EAAE,CAAC;EAAEC,MAAM,EAAE;AAAE,CAAC;AACnE,MAAMC,YAAY,GAAG;EACjBC,WAAW,EAAE,CAAC,CAAC;EAAEC,QAAQ,EAAE,CAAC;EAAEC,aAAa,EAAE,CAAC;EAAEC,cAAc,EAAE,CAAC;EACjEC,SAAS,EAAE,CAAC,CAAC;EAAEC,iBAAiB,EAAE,CAAC;EAAEC,eAAe,EAAE,CAAC;EAAEC,KAAK,EAAE,CAAC;EACjEC,QAAQ,EAAE,IAAI;EAAEC,aAAa,EAAE,IAAI;EAAEC,UAAU,EAAE,CAAC;EAClDC,eAAe,EAAE,IAAI;EAAEC,wBAAwB,EAAE;AACrD,CAAC;AACD,eAAeC,WAAWA,CAACC,MAAM,EAAEd,WAAW,EAAE;EAC5C,OAAOc,MAAM,CAACd,WAAW,GAAG,CAAC,IAAIc,MAAM,CAACd,WAAW,GAAGA,WAAW,EAAE;IAC/D,IAAI,CAACc,MAAM,CAACL,aAAa,EAAE;MACvBK,MAAM,CAACL,aAAa,GAAG,CAAC,YAAY;QAChC,IAAI;UACA,MAAMT,WAAW,GAAG,MAAMc,MAAM,CAACC,QAAQ,CAACC,cAAc,CAAC,CAAC;UAC1D,IAAIhB,WAAW,GAAGc,MAAM,CAACd,WAAW,EAAE;YAClCc,MAAM,CAACd,WAAW,GAAGA,WAAW;UACpC;QACJ,CAAC,CACD,OAAOiB,KAAK,EAAE;UACVH,MAAM,CAACd,WAAW,GAAG,CAAC,CAAC;UACvBc,MAAM,CAACH,eAAe,GAAGM,KAAK;UAC9BH,MAAM,CAACF,wBAAwB,GAAGzB,OAAO,CAAC,CAAC;QAC/C;QACA2B,MAAM,CAACL,aAAa,GAAG,IAAI;MAC/B,CAAC,EAAE,CAAC;IACR;IACA,MAAMK,MAAM,CAACL,aAAa;IAC1BK,MAAM,CAACV,SAAS,EAAE;IAClB,IAAIU,MAAM,CAACH,eAAe,EAAE;MACxB;IACJ;EACJ;AACJ;AACA,SAASO,UAAUA,CAAC5B,KAAK,EAAE;EACvB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACf,OAAO,MAAM;EACjB;EACA,IAAI6B,KAAK,CAACC,OAAO,CAAC9B,KAAK,CAAC,EAAE;IACtB,OAAO,GAAG,GAAIA,KAAK,CAAC+B,GAAG,CAACH,UAAU,CAAC,CAAEI,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;EACxD;EACA,IAAI,OAAQhC,KAAM,KAAK,QAAQ,IAAI,OAAQA,KAAK,CAACiC,MAAO,KAAK,UAAU,EAAE;IACrE,OAAOL,UAAU,CAAC5B,KAAK,CAACiC,MAAM,CAAC,CAAC,CAAC;EACrC;EACA,QAAQ,OAAQjC,KAAM;IAClB,KAAK,SAAS;IACd,KAAK,QAAQ;MACT,OAAOA,KAAK,CAACI,QAAQ,CAAC,CAAC;IAC3B,KAAK,QAAQ;IACb,KAAK,QAAQ;MACT,OAAOvB,MAAM,CAACmB,KAAK,CAAC,CAACI,QAAQ,CAAC,CAAC;IACnC,KAAK,QAAQ;MACT,OAAOH,IAAI,CAACF,SAAS,CAACC,KAAK,CAAC;IAChC,KAAK,QAAQ;MAAE;QACX,MAAMkC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAClC,KAAK,CAAC;QAC/BkC,IAAI,CAACE,IAAI,CAAC,CAAC;QACX,OAAO,GAAG,GAAGF,IAAI,CAACH,GAAG,CAAEM,CAAC,IAAK,GAAGpC,IAAI,CAACF,SAAS,CAACsC,CAAC,CAAC,IAAIT,UAAU,CAAC5B,KAAK,CAACqC,CAAC,CAAC,CAAC,EAAE,CAAC,CAACL,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;MAChG;EACJ;EACAM,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAEvC,KAAK,CAAC;EACzC,MAAM,IAAIwC,KAAK,CAAC,QAAQ,CAAC;AAC7B;AACA,SAASC,eAAeA,CAACC,MAAM,EAAE1C,KAAK,EAAE;EACpC,IAAI,OAAO,IAAIA,KAAK,EAAE;IAClB,MAAM2B,KAAK,GAAG3B,KAAK,CAAC2B,KAAK;IACzB,IAAIgB,GAAG;IACP,IAAIlE,OAAO,CAACkD,KAAK,EAAE,gBAAgB,CAAC,EAAE;MAClCgB,GAAG,GAAGf,UAAU,CAACO,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,EAAEjB,KAAK,EAAE;QACtCkB,YAAY,EAAEC,SAAS;QAAEC,MAAM,EAAED,SAAS;QAAEE,IAAI,EAAEF;MACtD,CAAC,CAAC,CAAC;IACP,CAAC,MACI;MACDH,GAAG,GAAGf,UAAU,CAACD,KAAK,CAAC;IAC3B;IACA,OAAO;MAAEgB,GAAG;MAAE3C,KAAK,EAAE2B;IAAM,CAAC;EAChC;EACA,MAAMsB,MAAM,GAAGjD,KAAK,CAACiD,MAAM;EAC3B,OAAO;IAAEN,GAAG,EAAEf,UAAU,CAACqB,MAAM,CAAC;IAAEjD,KAAK,EAAEiD;EAAO,CAAC;AACrD;AACA;AACA;AACA,SAASC,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;EAClC,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvB,KAAK,MAAM;IAAEtD,KAAK;IAAE2C,GAAG;IAAEnC;EAAO,CAAC,IAAI4C,OAAO,EAAE;IAC1C,MAAMG,CAAC,GAAGF,KAAK,CAACG,GAAG,CAACb,GAAG,CAAC,IAAI;MAAE3C,KAAK;MAAEQ,MAAM,EAAE;IAAE,CAAC;IAChD+C,CAAC,CAAC/C,MAAM,IAAIA,MAAM;IAClB6C,KAAK,CAACI,GAAG,CAACd,GAAG,EAAEY,CAAC,CAAC;EACrB;EACA,IAAIG,IAAI,GAAG,IAAI;EACf,KAAK,MAAMC,CAAC,IAAIN,KAAK,CAACO,MAAM,CAAC,CAAC,EAAE;IAC5B,IAAID,CAAC,CAACnD,MAAM,IAAI2C,MAAM,KAAK,CAACO,IAAI,IAAIC,CAAC,CAACnD,MAAM,GAAGkD,IAAI,CAAClD,MAAM,CAAC,EAAE;MACzDkD,IAAI,GAAGC,CAAC;IACZ;EACJ;EACA,IAAID,IAAI,EAAE;IACN,OAAOA,IAAI,CAAC1D,KAAK;EACrB;EACA,OAAO8C,SAAS;AACpB;AACA,SAASe,SAASA,CAACV,MAAM,EAAEC,OAAO,EAAE;EAChC,IAAIU,YAAY,GAAG,CAAC;EACpB,MAAMC,QAAQ,GAAG,IAAIT,GAAG,CAAC,CAAC;EAC1B,IAAIU,SAAS,GAAG,IAAI;EACpB,MAAMJ,MAAM,GAAG,EAAE;EACjB,KAAK,MAAM;IAAE5D,KAAK;IAAE2C,GAAG;IAAEnC;EAAO,CAAC,IAAI4C,OAAO,EAAE;IAC1C,IAAIpD,KAAK,YAAYwC,KAAK,EAAE;MACxB,MAAMyB,CAAC,GAAGF,QAAQ,CAACP,GAAG,CAACb,GAAG,CAAC,IAAI;QAAE3C,KAAK;QAAEQ,MAAM,EAAE;MAAE,CAAC;MACnDyD,CAAC,CAACzD,MAAM,IAAIA,MAAM;MAClBuD,QAAQ,CAACN,GAAG,CAACd,GAAG,EAAEsB,CAAC,CAAC;MACpB,IAAID,SAAS,IAAI,IAAI,IAAIC,CAAC,CAACzD,MAAM,GAAGwD,SAAS,CAACxD,MAAM,EAAE;QAClDwD,SAAS,GAAGC,CAAC;MACjB;IACJ,CAAC,MACI;MACDL,MAAM,CAACM,IAAI,CAACrF,MAAM,CAACmB,KAAK,CAAC,CAAC;MAC1B8D,YAAY,IAAItD,MAAM;IAC1B;EACJ;EACA,IAAIsD,YAAY,GAAGX,MAAM,EAAE;IACvB;IACA,IAAIa,SAAS,IAAIA,SAAS,CAACxD,MAAM,IAAI2C,MAAM,EAAE;MACzC,OAAOa,SAAS,CAAChE,KAAK;IAC1B;IACA;IACA,OAAO8C,SAAS;EACpB;EACA;EACAc,MAAM,CAACxB,IAAI,CAAC,CAAC+B,CAAC,EAAEC,CAAC,KAAOD,CAAC,GAAGC,CAAC,GAAI,CAAC,CAAC,GAAIA,CAAC,GAAGD,CAAC,GAAI,CAAC,GAAG,CAAE,CAAC;EACvD,MAAME,GAAG,GAAGjF,IAAI,CAACC,KAAK,CAACuE,MAAM,CAAC1E,MAAM,GAAG,CAAC,CAAC;EACzC;EACA,IAAI0E,MAAM,CAAC1E,MAAM,GAAG,CAAC,EAAE;IACnB,OAAO0E,MAAM,CAACS,GAAG,CAAC;EACtB;EACA;EACA,OAAO,CAACT,MAAM,CAACS,GAAG,GAAG,CAAC,CAAC,GAAGT,MAAM,CAACS,GAAG,CAAC,GAAGzF,IAAI,IAAIE,IAAI;AACxD;AACA,SAASwF,YAAYA,CAACnB,MAAM,EAAEC,OAAO,EAAE;EACnC;EACA,MAAMH,MAAM,GAAGC,WAAW,CAACC,MAAM,EAAEC,OAAO,CAAC;EAC3C,IAAIH,MAAM,KAAKH,SAAS,EAAE;IACtB,OAAOG,MAAM;EACjB;EACA;EACA,KAAK,MAAMU,CAAC,IAAIP,OAAO,EAAE;IACrB,IAAIO,CAAC,CAAC3D,KAAK,EAAE;MACT,OAAO2D,CAAC,CAAC3D,KAAK;IAClB;EACJ;EACA;EACA,OAAO8C,SAAS;AACpB;AACA,SAASyB,YAAYA,CAACpB,MAAM,EAAEC,OAAO,EAAE;EACnC,IAAID,MAAM,KAAK,CAAC,EAAE;IACd,OAAO3E,SAAS,CAACqF,SAAS,CAACV,MAAM,EAAEC,OAAO,CAAC,EAAE,WAAW,CAAC;EAC7D;EACA,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvB,MAAMkB,GAAG,GAAGA,CAACvB,MAAM,EAAEzC,MAAM,KAAK;IAC5B,MAAM+C,CAAC,GAAGF,KAAK,CAACG,GAAG,CAACP,MAAM,CAAC,IAAI;MAAEA,MAAM;MAAEzC,MAAM,EAAE;IAAE,CAAC;IACpD+C,CAAC,CAAC/C,MAAM,IAAIA,MAAM;IAClB6C,KAAK,CAACI,GAAG,CAACR,MAAM,EAAEM,CAAC,CAAC;EACxB,CAAC;EACD,KAAK,MAAM;IAAE/C,MAAM;IAAER;EAAM,CAAC,IAAIoD,OAAO,EAAE;IACrC,MAAMO,CAAC,GAAGnF,SAAS,CAACwB,KAAK,CAAC;IAC1BwE,GAAG,CAACb,CAAC,GAAG,CAAC,EAAEnD,MAAM,CAAC;IAClBgE,GAAG,CAACb,CAAC,EAAEnD,MAAM,CAAC;IACdgE,GAAG,CAACb,CAAC,GAAG,CAAC,EAAEnD,MAAM,CAAC;EACtB;EACA,IAAIiE,UAAU,GAAG,CAAC;EAClB,IAAIC,UAAU,GAAG5B,SAAS;EAC1B,KAAK,MAAM;IAAEtC,MAAM;IAAEyC;EAAO,CAAC,IAAII,KAAK,CAACO,MAAM,CAAC,CAAC,EAAE;IAC7C;IACA;IACA;IACA,IAAIpD,MAAM,IAAI2C,MAAM,KAAK3C,MAAM,GAAGiE,UAAU,IAAKC,UAAU,IAAI,IAAI,IAAIlE,MAAM,KAAKiE,UAAU,IAAIxB,MAAM,GAAGyB,UAAW,CAAC,EAAE;MACnHD,UAAU,GAAGjE,MAAM;MACnBkE,UAAU,GAAGzB,MAAM;IACvB;EACJ;EACA,OAAOyB,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,SAASjG,gBAAgB,CAAC;EACnD;AACJ;AACA;AACA;EACIyE,MAAM;EACN;AACJ;AACA;EACIyB,WAAW;EACX;AACJ;AACA;EACIC,YAAY;EACZ,CAACC,OAAO;EACR,CAACC,MAAM;EACP,CAACC,kBAAkB;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACC,SAAS,EAAEC,OAAO,EAAEC,OAAO,EAAE;IACrC,KAAK,CAACD,OAAO,EAAEC,OAAO,CAAC;IACvB,IAAI,CAAC,CAACN,OAAO,GAAGI,SAAS,CAACnD,GAAG,CAAEsD,CAAC,IAAK;MACjC,IAAIA,CAAC,YAAY3G,gBAAgB,EAAE;QAC/B,OAAOyD,MAAM,CAACS,MAAM,CAAC;UAAEnB,QAAQ,EAAE4D;QAAE,CAAC,EAAEhF,aAAa,EAAEI,YAAY,CAAC;MACtE,CAAC,MACI;QACD,OAAO0B,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,EAAEvC,aAAa,EAAEgF,CAAC,EAAE5E,YAAY,CAAC;MAC5D;IACJ,CAAC,CAAC;IACF,IAAI,CAAC,CAACsE,MAAM,GAAG,CAAC,CAAC;IACjB,IAAI,CAAC,CAACC,kBAAkB,GAAG,IAAI;IAC/B,IAAII,OAAO,IAAIA,OAAO,CAACjC,MAAM,IAAI,IAAI,EAAE;MACnC,IAAI,CAACA,MAAM,GAAGiC,OAAO,CAACjC,MAAM;IAChC,CAAC,MACI;MACD,IAAI,CAACA,MAAM,GAAG/D,IAAI,CAACkG,IAAI,CAAC,IAAI,CAAC,CAACR,OAAO,CAACS,MAAM,CAAC,CAACC,KAAK,EAAEhE,MAAM,KAAK;QAC5DgE,KAAK,IAAIhE,MAAM,CAAChB,MAAM;QACtB,OAAOgF,KAAK;MAChB,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;IACd;IACA,IAAI,CAACZ,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrBvG,cAAc,CAAC,IAAI,CAAC6E,MAAM,IAAI,IAAI,CAAC,CAAC2B,OAAO,CAACS,MAAM,CAAC,CAACpB,CAAC,EAAEsB,CAAC,KAAMtB,CAAC,GAAGsB,CAAC,CAACjF,MAAO,EAAE,CAAC,CAAC,EAAE,+BAA+B,EAAE,QAAQ,EAAE,IAAI,CAAC2C,MAAM,CAAC;EAC5I;EACA,IAAIuC,eAAeA,CAAA,EAAG;IAClB,OAAO,IAAI,CAAC,CAACZ,OAAO,CAAC/C,GAAG,CAAE0D,CAAC,IAAK;MAC5B,MAAMxC,MAAM,GAAGd,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,EAAE6C,CAAC,CAAC;MACnC,KAAK,MAAMvF,GAAG,IAAI+C,MAAM,EAAE;QACtB,IAAI/C,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAChB,OAAO+C,MAAM,CAAC/C,GAAG,CAAC;QACtB;MACJ;MACA,OAAO+C,MAAM;IACjB,CAAC,CAAC;EACN;EACA,MAAM0C,cAAcA,CAAA,EAAG;IACnB,OAAOhH,OAAO,CAACiH,IAAI,CAACrH,SAAS,CAAC,MAAM,IAAI,CAACsH,QAAQ,CAAC;MAAEnD,MAAM,EAAE;IAAU,CAAC,CAAC,CAAC,CAAC;EAC9E;EACA;EACA;EACA;EACA;EACA;AACJ;AACA;EACI,MAAMoD,iBAAiBA,CAACrE,QAAQ,EAAEsE,GAAG,EAAE;IACnC,QAAQA,GAAG,CAACrD,MAAM;MACd,KAAK,sBAAsB;QACvB,OAAO,MAAMjB,QAAQ,CAACuE,oBAAoB,CAACD,GAAG,CAACE,iBAAiB,CAAC;MACrE,KAAK,MAAM;QACP,OAAO,MAAMxE,QAAQ,CAACyE,IAAI,CAAC/D,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,EAAEmD,GAAG,CAACI,WAAW,EAAE;UAAEC,QAAQ,EAAEL,GAAG,CAACK;QAAS,CAAC,CAAC,CAAC;MAC9F,KAAK,SAAS;QACV,OAAO,CAAC,MAAM3E,QAAQ,CAAC4E,UAAU,CAAC,CAAC,EAAEC,OAAO;MAChD,KAAK,aAAa;QACd,OAAO,MAAM7E,QAAQ,CAAC8E,WAAW,CAACR,GAAG,CAACI,WAAW,CAAC;MACtD,KAAK,YAAY;QACb,OAAO,MAAM1E,QAAQ,CAAC+E,UAAU,CAACT,GAAG,CAACU,OAAO,EAAEV,GAAG,CAACK,QAAQ,CAAC;MAC/D,KAAK,UAAU;QAAE;UACb,MAAMM,KAAK,GAAI,WAAW,IAAIX,GAAG,GAAIA,GAAG,CAACY,SAAS,GAAGZ,GAAG,CAACK,QAAQ;UACjE,OAAO,MAAM3E,QAAQ,CAACmF,QAAQ,CAACF,KAAK,EAAEX,GAAG,CAACc,mBAAmB,CAAC;QAClE;MACA,KAAK,gBAAgB;QACjB,OAAO,MAAMpF,QAAQ,CAACC,cAAc,CAAC,CAAC;MAC1C,KAAK,SAAS;QACV,OAAO,MAAMD,QAAQ,CAACqF,OAAO,CAACf,GAAG,CAACU,OAAO,EAAEV,GAAG,CAACK,QAAQ,CAAC;MAC5D,KAAK,aAAa;QACd,OAAO,CAAC,MAAM3E,QAAQ,CAACsF,UAAU,CAAC,CAAC,EAAEC,QAAQ;MACjD,KAAK,gBAAgB;QACjB,OAAO,CAAC,MAAMvF,QAAQ,CAACsF,UAAU,CAAC,CAAC,EAAEE,oBAAoB;MAC7D,KAAK,SAAS;QACV,OAAO,MAAMxF,QAAQ,CAACyF,OAAO,CAACnB,GAAG,CAACoB,MAAM,CAAC;MAC7C,KAAK,YAAY;QACb,OAAO,MAAM1F,QAAQ,CAAC2F,UAAU,CAACrB,GAAG,CAACU,OAAO,EAAEV,GAAG,CAACsB,QAAQ,EAAEtB,GAAG,CAACK,QAAQ,CAAC;MAC7E,KAAK,gBAAgB;QACjB,OAAO,MAAM3E,QAAQ,CAAC6F,cAAc,CAACvB,GAAG,CAACwB,IAAI,CAAC;MAClD,KAAK,qBAAqB;QACtB,OAAO,MAAM9F,QAAQ,CAAC+F,mBAAmB,CAACzB,GAAG,CAACU,OAAO,EAAEV,GAAG,CAACK,QAAQ,CAAC;MACxE,KAAK,uBAAuB;QACxB,OAAO,MAAM3E,QAAQ,CAACgG,qBAAqB,CAAC1B,GAAG,CAACwB,IAAI,CAAC;MACzD,KAAK,sBAAsB;QACvB,OAAO,MAAM9F,QAAQ,CAACiG,oBAAoB,CAAC3B,GAAG,CAACwB,IAAI,CAAC;IAC5D;EACJ;EACA;EACA;EACA,CAACI,aAAaC,CAACC,OAAO,EAAE;IACpB;IACA;IACA;IACA,MAAM/C,OAAO,GAAGjD,KAAK,CAAC+D,IAAI,CAACiC,OAAO,CAAC,CAAC9F,GAAG,CAAE4B,CAAC,IAAKA,CAAC,CAACnC,MAAM,CAAC;IACxD;IACA,MAAMsG,UAAU,GAAG,IAAI,CAAC,CAAChD,OAAO,CAACiD,KAAK,CAAC,CAAC;IACxChJ,OAAO,CAAC+I,UAAU,CAAC;IACnBA,UAAU,CAAC1F,IAAI,CAAC,CAAC+B,CAAC,EAAEC,CAAC,KAAMD,CAAC,CAAC5D,QAAQ,GAAG6D,CAAC,CAAC7D,QAAS,CAAC;IACpD,KAAK,MAAMiB,MAAM,IAAIsG,UAAU,EAAE;MAC7B,IAAItG,MAAM,CAACH,eAAe,EAAE;QACxB;MACJ;MACA,IAAIyD,OAAO,CAACkD,OAAO,CAACxG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;QAChC,OAAOA,MAAM;MACjB;IACJ;IACA,OAAO,IAAI;EACf;EACA;EACA,CAACyG,SAASC,CAACL,OAAO,EAAE9B,GAAG,EAAE;IACrB,MAAMvE,MAAM,GAAG,IAAI,CAAC,CAACmG,aAAa,CAACE,OAAO,CAAC;IAC3C;IACA,IAAIrG,MAAM,IAAI,IAAI,EAAE;MAChB,OAAO,IAAI;IACf;IACA;IACA,MAAM2G,MAAM,GAAG;MACX3G,MAAM;MAAEyB,MAAM,EAAE,IAAI;MAAEmF,OAAO,EAAE,KAAK;MACpCC,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE;IAC5B,CAAC;IACD,MAAMC,GAAG,GAAG1I,OAAO,CAAC,CAAC;IACrB;IACAsI,MAAM,CAACE,OAAO,GAAG,CAAC,YAAY;MAC1B,IAAI;QACA7G,MAAM,CAACb,QAAQ,EAAE;QACjB,MAAMsC,MAAM,GAAG,MAAM,IAAI,CAAC6C,iBAAiB,CAACtE,MAAM,CAACC,QAAQ,EAAEsE,GAAG,CAAC;QACjEoC,MAAM,CAAClF,MAAM,GAAG;UAAEA;QAAO,CAAC;MAC9B,CAAC,CACD,OAAOtB,KAAK,EAAE;QACVH,MAAM,CAACX,cAAc,EAAE;QACvBsH,MAAM,CAAClF,MAAM,GAAG;UAAEtB;QAAM,CAAC;MAC7B;MACA,MAAM6G,EAAE,GAAI3I,OAAO,CAAC,CAAC,GAAG0I,GAAI;MAC5B/G,MAAM,CAACJ,UAAU,IAAIoH,EAAE;MACvBhH,MAAM,CAACR,eAAe,GAAG,IAAI,GAAGQ,MAAM,CAACR,eAAe,GAAG,IAAI,GAAGwH,EAAE;MAClEL,MAAM,CAACE,OAAO,GAAG,IAAI;IACzB,CAAC,EAAE,CAAC;IACJ;IACA;IACAF,MAAM,CAACG,OAAO,GAAG,CAAC,YAAY;MAC1B,MAAM9I,KAAK,CAACgC,MAAM,CAAClB,YAAY,CAAC;MAChC6H,MAAM,CAACG,OAAO,GAAG,IAAI;IACzB,CAAC,EAAE,CAAC;IACJT,OAAO,CAACrD,GAAG,CAAC2D,MAAM,CAAC;IACnB,OAAOA,MAAM;EACjB;EACA;EACA;EACA,MAAM,CAACM,WAAWC,CAAA,EAAG;IACjB,IAAID,WAAW,GAAG,IAAI,CAAC,CAACzD,kBAAkB;IAC1C,IAAI,CAACyD,WAAW,EAAE;MACd,MAAME,QAAQ,GAAG,EAAE;MACnB,IAAI,CAAC,CAAC7D,OAAO,CAAC8D,OAAO,CAAEpH,MAAM,IAAK;QAC9BmH,QAAQ,CAACzE,IAAI,CAAC,CAAC,YAAY;UACvB,MAAM3C,WAAW,CAACC,MAAM,EAAE,CAAC,CAAC;UAC5B,IAAI,CAACA,MAAM,CAACH,eAAe,EAAE;YACzBG,MAAM,CAACN,QAAQ,GAAG,MAAMM,MAAM,CAACC,QAAQ,CAAC4E,UAAU,CAAC,CAAC;UACxD;QACJ,CAAC,EAAE,CAAC,CAAC;MACT,CAAC,CAAC;MACF,IAAI,CAAC,CAACrB,kBAAkB,GAAGyD,WAAW,GAAG,CAAC,YAAY;QAClD;QACA,MAAM/I,OAAO,CAACmJ,GAAG,CAACF,QAAQ,CAAC;QAC3B;QACA,IAAIrC,OAAO,GAAG,IAAI;QAClB,KAAK,MAAM9E,MAAM,IAAI,IAAI,CAAC,CAACsD,OAAO,EAAE;UAChC,IAAItD,MAAM,CAACH,eAAe,EAAE;YACxB;UACJ;UACA,MAAM8D,OAAO,GAAI3D,MAAM,CAACN,QAAS;UACjC,IAAIoF,OAAO,IAAI,IAAI,EAAE;YACjBA,OAAO,GAAGnB,OAAO,CAACmB,OAAO;UAC7B,CAAC,MACI,IAAInB,OAAO,CAACmB,OAAO,KAAKA,OAAO,EAAE;YAClCjI,MAAM,CAAC,KAAK,EAAE,4CAA4C,EAAE,uBAAuB,EAAE;cACjFyK,SAAS,EAAE;YACf,CAAC,CAAC;UACN;QACJ;MACJ,CAAC,EAAE,CAAC;IACR;IACA,MAAML,WAAW;EACrB;EACA,MAAM,CAACvF,WAAW6F,CAAClB,OAAO,EAAE9B,GAAG,EAAE;IAC7B;IACA,MAAM3C,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM+E,MAAM,IAAIN,OAAO,EAAE;MAC1B,IAAIM,MAAM,CAAClF,MAAM,IAAI,IAAI,EAAE;QACvB,MAAM;UAAEN,GAAG;UAAE3C;QAAM,CAAC,GAAGyC,eAAe,CAACsD,GAAG,CAACrD,MAAM,EAAEyF,MAAM,CAAClF,MAAM,CAAC;QACjEG,OAAO,CAACc,IAAI,CAAC;UAAEvB,GAAG;UAAE3C,KAAK;UAAEQ,MAAM,EAAE2H,MAAM,CAAC3G,MAAM,CAAChB;QAAO,CAAC,CAAC;MAC9D;IACJ;IACA;IACA,IAAI4C,OAAO,CAACmC,MAAM,CAAC,CAACpB,CAAC,EAAER,CAAC,KAAMQ,CAAC,GAAGR,CAAC,CAACnD,MAAO,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC2C,MAAM,EAAE;MAC3D,OAAOL,SAAS;IACpB;IACA,QAAQiD,GAAG,CAACrD,MAAM;MACd,KAAK,gBAAgB;QAAE;UACnB;UACA,IAAI,IAAI,CAAC,CAACqC,MAAM,KAAK,CAAC,CAAC,EAAE;YACrB,IAAI,CAAC,CAACA,MAAM,GAAG3F,IAAI,CAACkG,IAAI,CAAC9G,SAAS,CAACqF,SAAS,CAAC,IAAI,CAACV,MAAM,EAAE,IAAI,CAAC,CAAC2B,OAAO,CAACqC,MAAM,CAAE1B,CAAC,IAAM,CAACA,CAAC,CAACpE,eAAgB,CAAC,CAACU,GAAG,CAAE0D,CAAC,KAAM;cACpHzF,KAAK,EAAEyF,CAAC,CAAC/E,WAAW;cACpBiC,GAAG,EAAEnE,SAAS,CAACiH,CAAC,CAAC/E,WAAW,CAAC,CAACN,QAAQ,CAAC,CAAC;cACxCI,MAAM,EAAEiF,CAAC,CAACjF;YACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UACV;UACA;UACA;UACA,MAAMwI,IAAI,GAAGzE,YAAY,CAAC,IAAI,CAACpB,MAAM,EAAEC,OAAO,CAAC;UAC/C,IAAI4F,IAAI,KAAKlG,SAAS,EAAE;YACpB,OAAOA,SAAS;UACpB;UACA,IAAIkG,IAAI,GAAG,IAAI,CAAC,CAACjE,MAAM,EAAE;YACrB,IAAI,CAAC,CAACA,MAAM,GAAGiE,IAAI;UACvB;UACA,OAAO,IAAI,CAAC,CAACjE,MAAM;QACvB;MACA,KAAK,aAAa;MAClB,KAAK,gBAAgB;MACrB,KAAK,aAAa;QACd,OAAOlB,SAAS,CAAC,IAAI,CAACV,MAAM,EAAEC,OAAO,CAAC;MAC1C,KAAK,UAAU;QACX;QACA;QACA,IAAI,UAAU,IAAI2C,GAAG,IAAIA,GAAG,CAACK,QAAQ,KAAK,SAAS,EAAE;UACjD,OAAO9B,YAAY,CAAC,IAAI,CAACnB,MAAM,EAAEC,OAAO,CAAC;QAC7C;QACA,OAAOF,WAAW,CAAC,IAAI,CAACC,MAAM,EAAEC,OAAO,CAAC;MAC5C,KAAK,MAAM;MACX,KAAK,SAAS;MACd,KAAK,YAAY;MACjB,KAAK,qBAAqB;MAC1B,KAAK,SAAS;MACd,KAAK,YAAY;MACjB,KAAK,gBAAgB;MACrB,KAAK,uBAAuB;MAC5B,KAAK,SAAS;QACV,OAAOF,WAAW,CAAC,IAAI,CAACC,MAAM,EAAEC,OAAO,CAAC;MAC5C,KAAK,sBAAsB;QACvB,OAAOkB,YAAY,CAAC,IAAI,CAACnB,MAAM,EAAEC,OAAO,CAAC;IACjD;IACA/E,MAAM,CAAC,KAAK,EAAE,oBAAoB,EAAE,uBAAuB,EAAE;MACzDyK,SAAS,EAAE,YAAY/I,SAAS,CAACgG,GAAG,CAACrD,MAAM,CAAC;IAChD,CAAC,CAAC;EACN;EACA,MAAM,CAACuG,aAAaC,CAACrB,OAAO,EAAE9B,GAAG,EAAE;IAC/B,IAAI8B,OAAO,CAACsB,IAAI,KAAK,CAAC,EAAE;MACpB,MAAM,IAAI3G,KAAK,CAAC,cAAc,CAAC;IACnC;IACA;IACA;IACA,MAAM4G,WAAW,GAAG,EAAE;IACtB,IAAIC,UAAU,GAAG,CAAC;IAClB,KAAK,MAAMlB,MAAM,IAAIN,OAAO,EAAE;MAC1B;MACA,IAAIM,MAAM,CAACE,OAAO,EAAE;QAChBe,WAAW,CAAClF,IAAI,CAACiE,MAAM,CAACE,OAAO,CAAC;MACpC;MACA;MACA,IAAIF,MAAM,CAACG,OAAO,EAAE;QAChBc,WAAW,CAAClF,IAAI,CAACiE,MAAM,CAACG,OAAO,CAAC;QAChC;MACJ;MACA;MACA,IAAIH,MAAM,CAACC,OAAO,EAAE;QAChB;MACJ;MACA;MACAD,MAAM,CAACC,OAAO,GAAG,IAAI;MACrBiB,UAAU,EAAE;IAChB;IACA;IACA,MAAMrJ,KAAK,GAAG,MAAM,IAAI,CAAC,CAACkD,WAAW,CAAC2E,OAAO,EAAE9B,GAAG,CAAC;IACnD,IAAI/F,KAAK,KAAK8C,SAAS,EAAE;MACrB,IAAI9C,KAAK,YAAYwC,KAAK,EAAE;QACxB,MAAMxC,KAAK;MACf;MACA,OAAOA,KAAK;IAChB;IACA;IACA;IACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoK,UAAU,EAAEpK,CAAC,EAAE,EAAE;MACjC,IAAI,CAAC,CAACgJ,SAAS,CAACJ,OAAO,EAAE9B,GAAG,CAAC;IACjC;IACA;IACA1H,MAAM,CAAC+K,WAAW,CAAClK,MAAM,GAAG,CAAC,EAAE,gBAAgB,EAAE,cAAc,EAAE;MAC7DoK,OAAO,EAAE,eAAe;MACxBtG,IAAI,EAAE;QAAEsG,OAAO,EAAEvD,GAAG;QAAE3C,OAAO,EAAEvB,KAAK,CAAC+D,IAAI,CAACiC,OAAO,CAAC,CAAC9F,GAAG,CAAE4B,CAAC,IAAK5D,SAAS,CAAC4D,CAAC,CAACV,MAAM,CAAC;MAAE;IACvF,CAAC,CAAC;IACF;IACA,MAAMvD,OAAO,CAAC6J,IAAI,CAACH,WAAW,CAAC;IAC/B;IACA;IACA,OAAO,MAAM,IAAI,CAAC,CAACH,aAAa,CAACpB,OAAO,EAAE9B,GAAG,CAAC;EAClD;EACA,MAAMF,QAAQA,CAACE,GAAG,EAAE;IAChB;IACA;IACA;IACA,IAAIA,GAAG,CAACrD,MAAM,KAAK,sBAAsB,EAAE;MACvC;MACA;MACA,MAAMU,OAAO,GAAG,IAAI,CAAC,CAAC0B,OAAO,CAAC/C,GAAG,CAAE0D,CAAC,IAAK,IAAI,CAAC;MAC9C,MAAM+D,UAAU,GAAG,IAAI,CAAC,CAAC1E,OAAO,CAAC/C,GAAG,CAAC,OAAO;QAAEN,QAAQ;QAAEjB;MAAO,CAAC,EAAEiJ,KAAK,KAAK;QACxE,IAAI;UACA,MAAMxG,MAAM,GAAG,MAAMxB,QAAQ,CAACoE,QAAQ,CAACE,GAAG,CAAC;UAC3C3C,OAAO,CAACqG,KAAK,CAAC,GAAGtH,MAAM,CAACS,MAAM,CAACH,eAAe,CAACsD,GAAG,CAACrD,MAAM,EAAE;YAAEO;UAAO,CAAC,CAAC,EAAE;YAAEzC;UAAO,CAAC,CAAC;QACvF,CAAC,CACD,OAAOmB,KAAK,EAAE;UACVyB,OAAO,CAACqG,KAAK,CAAC,GAAGtH,MAAM,CAACS,MAAM,CAACH,eAAe,CAACsD,GAAG,CAACrD,MAAM,EAAE;YAAEf;UAAM,CAAC,CAAC,EAAE;YAAEnB;UAAO,CAAC,CAAC;QACtF;MACJ,CAAC,CAAC;MACF;MACA,OAAO,IAAI,EAAE;QACT;QACA,MAAMkJ,IAAI,GAAGtG,OAAO,CAAC+D,MAAM,CAAExD,CAAC,IAAMA,CAAC,IAAI,IAAK,CAAC;QAC/C,KAAK,MAAM;UAAE3D;QAAM,CAAC,IAAI0J,IAAI,EAAE;UAC1B,IAAI,EAAE1J,KAAK,YAAYwC,KAAK,CAAC,EAAE;YAC3B,OAAOxC,KAAK;UAChB;QACJ;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAMiD,MAAM,GAAGC,WAAW,CAAC,IAAI,CAACC,MAAM,EAAEC,OAAO,CAAC+D,MAAM,CAAExD,CAAC,IAAMA,CAAC,IAAI,IAAK,CAAC,CAAC;QAC3E,IAAIlF,OAAO,CAACwE,MAAM,EAAE,oBAAoB,CAAC,EAAE;UACvC,MAAMA,MAAM;QAChB;QACA;QACA,MAAM0G,OAAO,GAAGH,UAAU,CAACrC,MAAM,CAAC,CAAC/C,CAAC,EAAEnF,CAAC,KAAMmE,OAAO,CAACnE,CAAC,CAAC,IAAI,IAAK,CAAC;QACjE,IAAI0K,OAAO,CAACzK,MAAM,KAAK,CAAC,EAAE;UACtB;QACJ;QACA,MAAMQ,OAAO,CAAC6J,IAAI,CAACI,OAAO,CAAC;MAC/B;MACA;MACA;MACA,MAAM1G,MAAM,GAAGqB,YAAY,CAAC,IAAI,CAACnB,MAAM,EAAEC,OAAO,CAAC;MACjD/E,MAAM,CAAC4E,MAAM,KAAKH,SAAS,EAAE,4BAA4B,EAAE,cAAc,EAAE;QACvEwG,OAAO,EAAE,eAAe;QACxBtG,IAAI,EAAE;UAAEsG,OAAO,EAAEvD,GAAG;UAAE3C,OAAO,EAAEA,OAAO,CAACrB,GAAG,CAAChC,SAAS;QAAE;MAC1D,CAAC,CAAC;MACF,IAAIkD,MAAM,YAAYT,KAAK,EAAE;QACzB,MAAMS,MAAM;MAChB;MACA,OAAOA,MAAM;IACjB;IACA,MAAM,IAAI,CAAC,CAACwF,WAAW,CAAC,CAAC;IACzB;IACA,MAAMZ,OAAO,GAAG,IAAI+B,GAAG,CAAC,CAAC;IACzB,IAAIC,cAAc,GAAG,CAAC;IACtB,OAAO,IAAI,EAAE;MACT,MAAM1B,MAAM,GAAG,IAAI,CAAC,CAACF,SAAS,CAACJ,OAAO,EAAE9B,GAAG,CAAC;MAC5C,IAAIoC,MAAM,IAAI,IAAI,EAAE;QAChB;MACJ;MACA0B,cAAc,IAAI1B,MAAM,CAAC3G,MAAM,CAAChB,MAAM;MACtC,IAAIqJ,cAAc,IAAI,IAAI,CAAC1G,MAAM,EAAE;QAC/B;MACJ;IACJ;IACA,MAAMF,MAAM,GAAG,MAAM,IAAI,CAAC,CAACgG,aAAa,CAACpB,OAAO,EAAE9B,GAAG,CAAC;IACtD;IACA;IACA,KAAK,MAAMoC,MAAM,IAAIN,OAAO,EAAE;MAC1B,IAAIM,MAAM,CAACE,OAAO,IAAIF,MAAM,CAAClF,MAAM,IAAI,IAAI,EAAE;QACzCkF,MAAM,CAAC3G,MAAM,CAACZ,aAAa,EAAE;MACjC;IACJ;IACA,OAAOqC,MAAM;EACjB;EACA,MAAM6G,OAAOA,CAAA,EAAG;IACZ,KAAK,MAAM;MAAErI;IAAS,CAAC,IAAI,IAAI,CAAC,CAACqD,OAAO,EAAE;MACtCrD,QAAQ,CAACqI,OAAO,CAAC,CAAC;IACtB;IACA,KAAK,CAACA,OAAO,CAAC,CAAC;EACnB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}