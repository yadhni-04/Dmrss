{"ast":null,"code":"import { assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiPollingProvider } from \"./provider-jsonrpc.js\";\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nexport class BrowserProvider extends JsonRpcApiPollingProvider {\n  #request;\n  #providerInfo;\n  /**\n   *  Connect to the %%ethereum%% provider, optionally forcing the\n   *  %%network%%.\n   */\n  constructor(ethereum, network, _options) {\n    // Copy the options\n    const options = Object.assign({}, _options != null ? _options : {}, {\n      batchMaxCount: 1\n    });\n    assertArgument(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n    super(network, options);\n    this.#providerInfo = null;\n    if (_options && _options.providerInfo) {\n      this.#providerInfo = _options.providerInfo;\n    }\n    this.#request = async (method, params) => {\n      const payload = {\n        method,\n        params\n      };\n      this.emit(\"debug\", {\n        action: \"sendEip1193Request\",\n        payload\n      });\n      try {\n        const result = await ethereum.request(payload);\n        this.emit(\"debug\", {\n          action: \"receiveEip1193Result\",\n          result\n        });\n        return result;\n      } catch (e) {\n        const error = new Error(e.message);\n        error.code = e.code;\n        error.data = e.data;\n        error.payload = payload;\n        this.emit(\"debug\", {\n          action: \"receiveEip1193Error\",\n          error\n        });\n        throw error;\n      }\n    };\n  }\n  get providerInfo() {\n    return this.#providerInfo;\n  }\n  async send(method, params) {\n    await this._start();\n    return await super.send(method, params);\n  }\n  async _send(payload) {\n    assertArgument(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n    try {\n      const result = await this.#request(payload.method, payload.params || []);\n      return [{\n        id: payload.id,\n        result\n      }];\n    } catch (e) {\n      return [{\n        id: payload.id,\n        error: {\n          code: e.code,\n          data: e.data,\n          message: e.message\n        }\n      }];\n    }\n  }\n  getRpcError(payload, error) {\n    error = JSON.parse(JSON.stringify(error));\n    // EIP-1193 gives us some machine-readable error codes, so rewrite\n    // them into Ethers standard errors.\n    switch (error.error.code || -1) {\n      case 4001:\n        error.error.message = `ethers-user-denied: ${error.error.message}`;\n        break;\n      case 4200:\n        error.error.message = `ethers-unsupported: ${error.error.message}`;\n        break;\n    }\n    return super.getRpcError(payload, error);\n  }\n  /**\n   *  Resolves to ``true`` if the provider manages the %%address%%.\n   */\n  async hasSigner(address) {\n    if (address == null) {\n      address = 0;\n    }\n    const accounts = await this.send(\"eth_accounts\", []);\n    if (typeof address === \"number\") {\n      return accounts.length > address;\n    }\n    address = address.toLowerCase();\n    return accounts.filter(a => a.toLowerCase() === address).length !== 0;\n  }\n  async getSigner(address) {\n    if (address == null) {\n      address = 0;\n    }\n    if (!(await this.hasSigner(address))) {\n      try {\n        await this.#request(\"eth_requestAccounts\", []);\n      } catch (error) {\n        const payload = error.payload;\n        throw this.getRpcError(payload, {\n          id: payload.id,\n          error\n        });\n      }\n    }\n    return await super.getSigner(address);\n  }\n  /**\n   *  Discover and connect to a Provider in the Browser using the\n   *  [[link-eip-6963]] discovery mechanism. If no providers are\n   *  present, ``null`` is resolved.\n   */\n  static async discover(options) {\n    if (options == null) {\n      options = {};\n    }\n    if (options.provider) {\n      return new BrowserProvider(options.provider);\n    }\n    const context = options.window ? options.window : typeof window !== \"undefined\" ? window : null;\n    if (context == null) {\n      return null;\n    }\n    const anyProvider = options.anyProvider;\n    if (anyProvider && context.ethereum) {\n      return new BrowserProvider(context.ethereum);\n    }\n    if (!(\"addEventListener\" in context && \"dispatchEvent\" in context && \"removeEventListener\" in context)) {\n      return null;\n    }\n    const timeout = options.timeout ? options.timeout : 300;\n    if (timeout === 0) {\n      return null;\n    }\n    return await new Promise((resolve, reject) => {\n      let found = [];\n      const addProvider = event => {\n        found.push(event.detail);\n        if (anyProvider) {\n          finalize();\n        }\n      };\n      const finalize = () => {\n        clearTimeout(timer);\n        if (found.length) {\n          // If filtering is provided:\n          if (options && options.filter) {\n            // Call filter, with a copies of found provider infos\n            const filtered = options.filter(found.map(i => Object.assign({}, i.info)));\n            if (filtered == null) {\n              // No provider selected\n              resolve(null);\n            } else if (filtered instanceof BrowserProvider) {\n              // Custom provider created\n              resolve(filtered);\n            } else {\n              // Find the matching provider\n              let match = null;\n              if (filtered.uuid) {\n                const matches = found.filter(f => filtered.uuid === f.info.uuid);\n                // @TODO: What should happen if multiple values\n                //        for the same UUID?\n                match = matches[0];\n              }\n              if (match) {\n                const {\n                  provider,\n                  info\n                } = match;\n                resolve(new BrowserProvider(provider, undefined, {\n                  providerInfo: info\n                }));\n              } else {\n                reject(makeError(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                  value: filtered\n                }));\n              }\n            }\n          } else {\n            // Pick the first found provider\n            const {\n              provider,\n              info\n            } = found[0];\n            resolve(new BrowserProvider(provider, undefined, {\n              providerInfo: info\n            }));\n          }\n        } else {\n          // Nothing found\n          resolve(null);\n        }\n        context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n      };\n      const timer = setTimeout(() => {\n        finalize();\n      }, timeout);\n      context.addEventListener(\"eip6963:announceProvider\", addProvider);\n      context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n    });\n  }\n}","map":{"version":3,"names":["assertArgument","makeError","JsonRpcApiPollingProvider","BrowserProvider","request","providerInfo","constructor","ethereum","network","_options","options","Object","assign","batchMaxCount","method","params","payload","emit","action","result","e","error","Error","message","code","data","send","_start","_send","Array","isArray","id","getRpcError","JSON","parse","stringify","hasSigner","address","accounts","length","toLowerCase","filter","a","getSigner","discover","provider","context","window","anyProvider","timeout","Promise","resolve","reject","found","addProvider","event","push","detail","finalize","clearTimeout","timer","filtered","map","i","info","match","uuid","matches","f","undefined","value","removeEventListener","setTimeout","addEventListener","dispatchEvent","Event"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/providers/provider-browser.js"],"sourcesContent":["import { assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiPollingProvider } from \"./provider-jsonrpc.js\";\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nexport class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request;\n    #providerInfo;\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */\n    constructor(ethereum, network, _options) {\n        // Copy the options\n        const options = Object.assign({}, ((_options != null) ? _options : {}), { batchMaxCount: 1 });\n        assertArgument(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        this.#providerInfo = null;\n        if (_options && _options.providerInfo) {\n            this.#providerInfo = _options.providerInfo;\n        }\n        this.#request = async (method, params) => {\n            const payload = { method, params };\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\n                return result;\n            }\n            catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\n                throw error;\n            }\n        };\n    }\n    get providerInfo() {\n        return this.#providerInfo;\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        assertArgument(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [{ id: payload.id, result }];\n        }\n        catch (e) {\n            return [{\n                    id: payload.id,\n                    error: { code: e.code, data: e.data, message: e.message }\n                }];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch (error.error.code || -1) {\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */\n    async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof (address) === \"number\") {\n            return (accounts.length > address);\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!(await this.hasSigner(address))) {\n            try {\n                await this.#request(\"eth_requestAccounts\", []);\n            }\n            catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, { id: payload.id, error });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */\n    static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window :\n            (typeof (window) !== \"undefined\") ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context\n            && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await (new Promise((resolve, reject) => {\n            let found = [];\n            const addProvider = (event) => {\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = () => {\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map(i => Object.assign({}, (i.info))));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        }\n                        else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        }\n                        else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter(f => (filtered.uuid === f.info.uuid));\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            }\n                            else {\n                                reject(makeError(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    }\n                    else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                }\n                else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(() => { finalize(); }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        }));\n    }\n}\n//# sourceMappingURL=provider-browser.js.map"],"mappings":"AAAA,SAASA,cAAc,EAAEC,SAAS,QAAQ,mBAAmB;AAC7D,SAASC,yBAAyB,QAAQ,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,SAASD,yBAAyB,CAAC;EAC3D,CAACE,OAAO;EACR,CAACC,YAAY;EACb;AACJ;AACA;AACA;EACIC,WAAWA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAE;IACrC;IACA,MAAMC,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAIH,QAAQ,IAAI,IAAI,GAAIA,QAAQ,GAAG,CAAC,CAAC,EAAG;MAAEI,aAAa,EAAE;IAAE,CAAC,CAAC;IAC7Fb,cAAc,CAACO,QAAQ,IAAIA,QAAQ,CAACH,OAAO,EAAE,2BAA2B,EAAE,UAAU,EAAEG,QAAQ,CAAC;IAC/F,KAAK,CAACC,OAAO,EAAEE,OAAO,CAAC;IACvB,IAAI,CAAC,CAACL,YAAY,GAAG,IAAI;IACzB,IAAII,QAAQ,IAAIA,QAAQ,CAACJ,YAAY,EAAE;MACnC,IAAI,CAAC,CAACA,YAAY,GAAGI,QAAQ,CAACJ,YAAY;IAC9C;IACA,IAAI,CAAC,CAACD,OAAO,GAAG,OAAOU,MAAM,EAAEC,MAAM,KAAK;MACtC,MAAMC,OAAO,GAAG;QAAEF,MAAM;QAAEC;MAAO,CAAC;MAClC,IAAI,CAACE,IAAI,CAAC,OAAO,EAAE;QAAEC,MAAM,EAAE,oBAAoB;QAAEF;MAAQ,CAAC,CAAC;MAC7D,IAAI;QACA,MAAMG,MAAM,GAAG,MAAMZ,QAAQ,CAACH,OAAO,CAACY,OAAO,CAAC;QAC9C,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE;UAAEC,MAAM,EAAE,sBAAsB;UAAEC;QAAO,CAAC,CAAC;QAC9D,OAAOA,MAAM;MACjB,CAAC,CACD,OAAOC,CAAC,EAAE;QACN,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAACF,CAAC,CAACG,OAAO,CAAC;QAClCF,KAAK,CAACG,IAAI,GAAGJ,CAAC,CAACI,IAAI;QACnBH,KAAK,CAACI,IAAI,GAAGL,CAAC,CAACK,IAAI;QACnBJ,KAAK,CAACL,OAAO,GAAGA,OAAO;QACvB,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE;UAAEC,MAAM,EAAE,qBAAqB;UAAEG;QAAM,CAAC,CAAC;QAC5D,MAAMA,KAAK;MACf;IACJ,CAAC;EACL;EACA,IAAIhB,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAAC,CAACA,YAAY;EAC7B;EACA,MAAMqB,IAAIA,CAACZ,MAAM,EAAEC,MAAM,EAAE;IACvB,MAAM,IAAI,CAACY,MAAM,CAAC,CAAC;IACnB,OAAO,MAAM,KAAK,CAACD,IAAI,CAACZ,MAAM,EAAEC,MAAM,CAAC;EAC3C;EACA,MAAMa,KAAKA,CAACZ,OAAO,EAAE;IACjBhB,cAAc,CAAC,CAAC6B,KAAK,CAACC,OAAO,CAACd,OAAO,CAAC,EAAE,yCAAyC,EAAE,SAAS,EAAEA,OAAO,CAAC;IACtG,IAAI;MACA,MAAMG,MAAM,GAAG,MAAM,IAAI,CAAC,CAACf,OAAO,CAACY,OAAO,CAACF,MAAM,EAAEE,OAAO,CAACD,MAAM,IAAI,EAAE,CAAC;MACxE,OAAO,CAAC;QAAEgB,EAAE,EAAEf,OAAO,CAACe,EAAE;QAAEZ;MAAO,CAAC,CAAC;IACvC,CAAC,CACD,OAAOC,CAAC,EAAE;MACN,OAAO,CAAC;QACAW,EAAE,EAAEf,OAAO,CAACe,EAAE;QACdV,KAAK,EAAE;UAAEG,IAAI,EAAEJ,CAAC,CAACI,IAAI;UAAEC,IAAI,EAAEL,CAAC,CAACK,IAAI;UAAEF,OAAO,EAAEH,CAAC,CAACG;QAAQ;MAC5D,CAAC,CAAC;IACV;EACJ;EACAS,WAAWA,CAAChB,OAAO,EAAEK,KAAK,EAAE;IACxBA,KAAK,GAAGY,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACd,KAAK,CAAC,CAAC;IACzC;IACA;IACA,QAAQA,KAAK,CAACA,KAAK,CAACG,IAAI,IAAI,CAAC,CAAC;MAC1B,KAAK,IAAI;QACLH,KAAK,CAACA,KAAK,CAACE,OAAO,GAAG,uBAAuBF,KAAK,CAACA,KAAK,CAACE,OAAO,EAAE;QAClE;MACJ,KAAK,IAAI;QACLF,KAAK,CAACA,KAAK,CAACE,OAAO,GAAG,uBAAuBF,KAAK,CAACA,KAAK,CAACE,OAAO,EAAE;QAClE;IACR;IACA,OAAO,KAAK,CAACS,WAAW,CAAChB,OAAO,EAAEK,KAAK,CAAC;EAC5C;EACA;AACJ;AACA;EACI,MAAMe,SAASA,CAACC,OAAO,EAAE;IACrB,IAAIA,OAAO,IAAI,IAAI,EAAE;MACjBA,OAAO,GAAG,CAAC;IACf;IACA,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACZ,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC;IACpD,IAAI,OAAQW,OAAQ,KAAK,QAAQ,EAAE;MAC/B,OAAQC,QAAQ,CAACC,MAAM,GAAGF,OAAO;IACrC;IACAA,OAAO,GAAGA,OAAO,CAACG,WAAW,CAAC,CAAC;IAC/B,OAAOF,QAAQ,CAACG,MAAM,CAAEC,CAAC,IAAMA,CAAC,CAACF,WAAW,CAAC,CAAC,KAAKH,OAAQ,CAAC,CAACE,MAAM,KAAK,CAAC;EAC7E;EACA,MAAMI,SAASA,CAACN,OAAO,EAAE;IACrB,IAAIA,OAAO,IAAI,IAAI,EAAE;MACjBA,OAAO,GAAG,CAAC;IACf;IACA,IAAI,EAAE,MAAM,IAAI,CAACD,SAAS,CAACC,OAAO,CAAC,CAAC,EAAE;MAClC,IAAI;QACA,MAAM,IAAI,CAAC,CAACjC,OAAO,CAAC,qBAAqB,EAAE,EAAE,CAAC;MAClD,CAAC,CACD,OAAOiB,KAAK,EAAE;QACV,MAAML,OAAO,GAAGK,KAAK,CAACL,OAAO;QAC7B,MAAM,IAAI,CAACgB,WAAW,CAAChB,OAAO,EAAE;UAAEe,EAAE,EAAEf,OAAO,CAACe,EAAE;UAAEV;QAAM,CAAC,CAAC;MAC9D;IACJ;IACA,OAAO,MAAM,KAAK,CAACsB,SAAS,CAACN,OAAO,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;EACI,aAAaO,QAAQA,CAAClC,OAAO,EAAE;IAC3B,IAAIA,OAAO,IAAI,IAAI,EAAE;MACjBA,OAAO,GAAG,CAAC,CAAC;IAChB;IACA,IAAIA,OAAO,CAACmC,QAAQ,EAAE;MAClB,OAAO,IAAI1C,eAAe,CAACO,OAAO,CAACmC,QAAQ,CAAC;IAChD;IACA,MAAMC,OAAO,GAAGpC,OAAO,CAACqC,MAAM,GAAGrC,OAAO,CAACqC,MAAM,GAC1C,OAAQA,MAAO,KAAK,WAAW,GAAIA,MAAM,GAAG,IAAI;IACrD,IAAID,OAAO,IAAI,IAAI,EAAE;MACjB,OAAO,IAAI;IACf;IACA,MAAME,WAAW,GAAGtC,OAAO,CAACsC,WAAW;IACvC,IAAIA,WAAW,IAAIF,OAAO,CAACvC,QAAQ,EAAE;MACjC,OAAO,IAAIJ,eAAe,CAAC2C,OAAO,CAACvC,QAAQ,CAAC;IAChD;IACA,IAAI,EAAE,kBAAkB,IAAIuC,OAAO,IAAI,eAAe,IAAIA,OAAO,IAC1D,qBAAqB,IAAIA,OAAO,CAAC,EAAE;MACtC,OAAO,IAAI;IACf;IACA,MAAMG,OAAO,GAAGvC,OAAO,CAACuC,OAAO,GAAGvC,OAAO,CAACuC,OAAO,GAAG,GAAG;IACvD,IAAIA,OAAO,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;IACf;IACA,OAAO,MAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MAC3C,IAAIC,KAAK,GAAG,EAAE;MACd,MAAMC,WAAW,GAAIC,KAAK,IAAK;QAC3BF,KAAK,CAACG,IAAI,CAACD,KAAK,CAACE,MAAM,CAAC;QACxB,IAAIT,WAAW,EAAE;UACbU,QAAQ,CAAC,CAAC;QACd;MACJ,CAAC;MACD,MAAMA,QAAQ,GAAGA,CAAA,KAAM;QACnBC,YAAY,CAACC,KAAK,CAAC;QACnB,IAAIP,KAAK,CAACd,MAAM,EAAE;UACd;UACA,IAAI7B,OAAO,IAAIA,OAAO,CAAC+B,MAAM,EAAE;YAC3B;YACA,MAAMoB,QAAQ,GAAGnD,OAAO,CAAC+B,MAAM,CAACY,KAAK,CAACS,GAAG,CAACC,CAAC,IAAIpD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAGmD,CAAC,CAACC,IAAK,CAAC,CAAC,CAAC;YAC5E,IAAIH,QAAQ,IAAI,IAAI,EAAE;cAClB;cACAV,OAAO,CAAC,IAAI,CAAC;YACjB,CAAC,MACI,IAAIU,QAAQ,YAAY1D,eAAe,EAAE;cAC1C;cACAgD,OAAO,CAACU,QAAQ,CAAC;YACrB,CAAC,MACI;cACD;cACA,IAAII,KAAK,GAAG,IAAI;cAChB,IAAIJ,QAAQ,CAACK,IAAI,EAAE;gBACf,MAAMC,OAAO,GAAGd,KAAK,CAACZ,MAAM,CAAC2B,CAAC,IAAKP,QAAQ,CAACK,IAAI,KAAKE,CAAC,CAACJ,IAAI,CAACE,IAAK,CAAC;gBAClE;gBACA;gBACAD,KAAK,GAAGE,OAAO,CAAC,CAAC,CAAC;cACtB;cACA,IAAIF,KAAK,EAAE;gBACP,MAAM;kBAAEpB,QAAQ;kBAAEmB;gBAAK,CAAC,GAAGC,KAAK;gBAChCd,OAAO,CAAC,IAAIhD,eAAe,CAAC0C,QAAQ,EAAEwB,SAAS,EAAE;kBAC7ChE,YAAY,EAAE2D;gBAClB,CAAC,CAAC,CAAC;cACP,CAAC,MACI;gBACDZ,MAAM,CAACnD,SAAS,CAAC,8BAA8B,EAAE,uBAAuB,EAAE;kBACtEqE,KAAK,EAAET;gBACX,CAAC,CAAC,CAAC;cACP;YACJ;UACJ,CAAC,MACI;YACD;YACA,MAAM;cAAEhB,QAAQ;cAAEmB;YAAK,CAAC,GAAGX,KAAK,CAAC,CAAC,CAAC;YACnCF,OAAO,CAAC,IAAIhD,eAAe,CAAC0C,QAAQ,EAAEwB,SAAS,EAAE;cAC7ChE,YAAY,EAAE2D;YAClB,CAAC,CAAC,CAAC;UACP;QACJ,CAAC,MACI;UACD;UACAb,OAAO,CAAC,IAAI,CAAC;QACjB;QACAL,OAAO,CAACyB,mBAAmB,CAAC,0BAA0B,EAAEjB,WAAW,CAAC;MACxE,CAAC;MACD,MAAMM,KAAK,GAAGY,UAAU,CAAC,MAAM;QAAEd,QAAQ,CAAC,CAAC;MAAE,CAAC,EAAET,OAAO,CAAC;MACxDH,OAAO,CAAC2B,gBAAgB,CAAC,0BAA0B,EAAEnB,WAAW,CAAC;MACjER,OAAO,CAAC4B,aAAa,CAAC,IAAIC,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/D,CAAC,CAAE;EACP;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}