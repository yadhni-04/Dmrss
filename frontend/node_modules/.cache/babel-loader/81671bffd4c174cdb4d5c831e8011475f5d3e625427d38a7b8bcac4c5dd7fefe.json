{"ast":null,"code":"import { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport { defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  assertNormalize(\"NFKD\");\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n  const words = wordlist.split(mnemonic);\n  assertArgument(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n  const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n  let offset = 0;\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset++;\n    }\n  }\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n  const indices = [0];\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nexport class Mnemonic {\n  /**\n   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n   *\n   *  Use the [[wordlist]] ``split`` method to get the individual words.\n   */\n  phrase;\n  /**\n   *  The password used for this mnemonic. If no password is used this\n   *  is the empty string (i.e. ``\"\"``) as per the specification.\n   */\n  password;\n  /**\n   *  The wordlist for this mnemonic.\n   */\n  wordlist;\n  /**\n   *  The underlying entropy which the mnemonic encodes.\n   */\n  entropy;\n  /**\n   *  @private\n   */\n  constructor(guard, entropy, phrase, password, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n    assertPrivate(guard, _guard, \"Mnemonic\");\n    defineProperties(this, {\n      phrase,\n      password,\n      wordlist,\n      entropy\n    });\n  }\n  /**\n   *  Returns the seed for the mnemonic.\n   */\n  computeSeed() {\n    const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n    return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n  }\n  /**\n   *  Creates a new Mnemonic for the %%phrase%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromPhrase(phrase, password, wordlist) {\n    // Normalize the case and space; throws if invalid\n    const entropy = mnemonicToEntropy(phrase, wordlist);\n    phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n    return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n  }\n  /**\n   *  Create a new **Mnemonic** from the %%entropy%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromEntropy(_entropy, password, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    const phrase = entropyToMnemonic(entropy, wordlist);\n    return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n  }\n  /**\n   *  Returns the phrase for %%mnemonic%%.\n   */\n  static entropyToPhrase(_entropy, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    return entropyToMnemonic(entropy, wordlist);\n  }\n  /**\n   *  Returns the entropy for %%phrase%%.\n   */\n  static phraseToEntropy(phrase, wordlist) {\n    return mnemonicToEntropy(phrase, wordlist);\n  }\n  /**\n   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n   *\n   *  This checks all the provided words belong to the %%wordlist%%,\n   *  that the length is valid and the checksum is correct.\n   */\n  static isValidMnemonic(phrase, wordlist) {\n    try {\n      mnemonicToEntropy(phrase, wordlist);\n      return true;\n    } catch (error) {}\n    return false;\n  }\n}","map":{"version":3,"names":["pbkdf2","sha256","defineProperties","getBytes","hexlify","assertNormalize","assertPrivate","assertArgument","toUtf8Bytes","LangEn","getUpperMask","bits","getLowerMask","mnemonicToEntropy","mnemonic","wordlist","words","split","length","entropy","Uint8Array","Math","ceil","offset","i","index","getWordIndex","normalize","bit","entropyBits","checksumBits","checksumMask","checksum","slice","entropyToMnemonic","indices","remainingBits","push","parseInt","substring","join","map","getWord","_guard","Mnemonic","phrase","password","constructor","guard","computeSeed","salt","fromPhrase","fromEntropy","_entropy","entropyToPhrase","phraseToEntropy","isValidMnemonic","error"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/wallet/mnemonic.js"],"sourcesContent":["import { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport { defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return ((1 << bits) - 1) & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    assertNormalize(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    assertArgument((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertArgument((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = LangEn.wordlist();\n    }\n    const indices = [0];\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nexport class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    phrase;\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    password;\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    wordlist;\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    entropy;\n    /**\n     *  @private\n     */\n    constructor(guard, entropy, phrase, password, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = LangEn.wordlist();\n        }\n        assertPrivate(guard, _guard, \"Mnemonic\");\n        defineProperties(this, { phrase, password, wordlist, entropy });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed() {\n        const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n        return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy, password, wordlist) {\n        const entropy = getBytes(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy, wordlist) {\n        const entropy = getBytes(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        }\n        catch (error) { }\n        return false;\n    }\n}\n//# sourceMappingURL=mnemonic.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}