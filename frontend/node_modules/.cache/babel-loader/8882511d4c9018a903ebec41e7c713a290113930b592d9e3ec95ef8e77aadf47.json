{"ast":null,"code":"/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport { getBigInt, getNumber, fromTwos, mask, toBigInt } from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n  Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n  let result = Zeros;\n  while (result.length < decimals) {\n    result += result;\n  }\n  return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n  const width = BigInt(format.width);\n  if (format.signed) {\n    const limit = BN_1 << width - BN_1;\n    assert(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n      operation: safeOp,\n      fault: \"overflow\",\n      value: val\n    });\n    if (val > BN_0) {\n      val = fromTwos(mask(val, width), width);\n    } else {\n      val = -fromTwos(mask(-val, width), width);\n    }\n  } else {\n    const limit = BN_1 << width;\n    assert(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n      operation: safeOp,\n      fault: \"overflow\",\n      value: val\n    });\n    val = (val % limit + limit) % limit & limit - BN_1;\n  }\n  return val;\n}\nfunction getFormat(value) {\n  if (typeof value === \"number\") {\n    value = `fixed128x${value}`;\n  }\n  let signed = true;\n  let width = 128;\n  let decimals = 18;\n  if (typeof value === \"string\") {\n    // Parse the format string\n    if (value === \"fixed\") {\n      // defaults...\n    } else if (value === \"ufixed\") {\n      signed = false;\n    } else {\n      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n      assertArgument(match, \"invalid fixed format\", \"format\", value);\n      signed = match[1] !== \"u\";\n      width = parseInt(match[2]);\n      decimals = parseInt(match[3]);\n    }\n  } else if (value) {\n    // Extract the values from the object\n    const v = value;\n    const check = (key, type, defaultValue) => {\n      if (v[key] == null) {\n        return defaultValue;\n      }\n      assertArgument(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n      return v[key];\n    };\n    signed = check(\"signed\", \"boolean\", signed);\n    width = check(\"width\", \"number\", width);\n    decimals = check(\"decimals\", \"number\", decimals);\n  }\n  assertArgument(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n  assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n  const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n  return {\n    signed,\n    width,\n    decimals,\n    name\n  };\n}\nfunction toString(val, decimals) {\n  let negative = \"\";\n  if (val < BN_0) {\n    negative = \"-\";\n    val *= BN_N1;\n  }\n  let str = val.toString();\n  // No decimal point for whole values\n  if (decimals === 0) {\n    return negative + str;\n  }\n  // Pad out to the whole component (including a whole digit)\n  while (str.length <= decimals) {\n    str = Zeros + str;\n  }\n  // Insert the decimal point\n  const index = str.length - decimals;\n  str = str.substring(0, index) + \".\" + str.substring(index);\n  // Trim the whole component (leaving at least one 0)\n  while (str[0] === \"0\" && str[1] !== \".\") {\n    str = str.substring(1);\n  }\n  // Trim the decimal component (leaving at least one 0)\n  while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n    str = str.substring(0, str.length - 1);\n  }\n  return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n  /**\n   *  The specific fixed-point arithmetic field for this value.\n   */\n  format;\n  #format;\n  // The actual value (accounting for decimals)\n  #val;\n  // A base-10 value to multiple values by to maintain the magnitude\n  #tens;\n  /**\n   *  This is a property so console.log shows a human-meaningful value.\n   *\n   *  @private\n   */\n  _value;\n  // Use this when changing this file to get some typing info,\n  // but then switch to any to mask the internal type\n  //constructor(guard: any, value: bigint, format: _FixedFormat) {\n  /**\n   *  @private\n   */\n  constructor(guard, value, format) {\n    assertPrivate(guard, _guard, \"FixedNumber\");\n    this.#val = value;\n    this.#format = format;\n    const _value = toString(value, format.decimals);\n    defineProperties(this, {\n      format: format.name,\n      _value\n    });\n    this.#tens = getTens(format.decimals);\n  }\n  /**\n   *  If true, negative values are permitted, otherwise only\n   *  positive values and zero are allowed.\n   */\n  get signed() {\n    return this.#format.signed;\n  }\n  /**\n   *  The number of bits available to store the value.\n   */\n  get width() {\n    return this.#format.width;\n  }\n  /**\n   *  The number of decimal places in the fixed-point arithment field.\n   */\n  get decimals() {\n    return this.#format.decimals;\n  }\n  /**\n   *  The value as an integer, based on the smallest unit the\n   *  [[decimals]] allow.\n   */\n  get value() {\n    return this.#val;\n  }\n  #checkFormat(other) {\n    assertArgument(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n  }\n  #checkValue(val, safeOp) {\n    /*\n            const width = BigInt(this.width);\n            if (this.signed) {\n                const limit = (BN_1 << (width - BN_1));\n                assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                    operation: <string>safeOp, fault: \"overflow\", value: val\n                });\n    \n                if (val > BN_0) {\n                    val = fromTwos(mask(val, width), width);\n                } else {\n                    val = -fromTwos(mask(-val, width), width);\n                }\n    \n            } else {\n                const masked = mask(val, width);\n                assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                    operation: <string>safeOp, fault: \"overflow\", value: val\n                });\n                val = masked;\n            }\n    */\n    val = checkValue(val, this.#format, safeOp);\n    return new FixedNumber(_guard, val, this.#format);\n  }\n  #add(o, safeOp) {\n    this.#checkFormat(o);\n    return this.#checkValue(this.#val + o.#val, safeOp);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% added\n   *  to %%other%%, ignoring overflow.\n   */\n  addUnsafe(other) {\n    return this.#add(other);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% added\n   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n   *  occurs.\n   */\n  add(other) {\n    return this.#add(other, \"add\");\n  }\n  #sub(o, safeOp) {\n    this.#checkFormat(o);\n    return this.#checkValue(this.#val - o.#val, safeOp);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n   *  from %%this%%, ignoring overflow.\n   */\n  subUnsafe(other) {\n    return this.#sub(other);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n   *  occurs.\n   */\n  sub(other) {\n    return this.#sub(other, \"sub\");\n  }\n  #mul(o, safeOp) {\n    this.#checkFormat(o);\n    return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n   *  by %%other%%, ignoring overflow and underflow (precision loss).\n   */\n  mulUnsafe(other) {\n    return this.#mul(other);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n   *  occurs.\n   */\n  mul(other) {\n    return this.#mul(other, \"mul\");\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n   *  occurs or if underflow (precision loss) occurs.\n   */\n  mulSignal(other) {\n    this.#checkFormat(other);\n    const value = this.#val * other.#val;\n    assert(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n      operation: \"mulSignal\",\n      fault: \"underflow\",\n      value: this\n    });\n    return this.#checkValue(value / this.#tens, \"mulSignal\");\n  }\n  #div(o, safeOp) {\n    assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n      operation: \"div\",\n      fault: \"divide-by-zero\",\n      value: this\n    });\n    this.#checkFormat(o);\n    return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n   *  by %%other%%, ignoring underflow (precision loss). A\n   *  [[NumericFaultError]] is thrown if overflow occurs.\n   */\n  divUnsafe(other) {\n    return this.#div(other);\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n   *  by %%other%%, ignoring underflow (precision loss). A\n   *  [[NumericFaultError]] is thrown if overflow occurs.\n   */\n  div(other) {\n    return this.#div(other, \"div\");\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n   *  (precision loss) occurs.\n   */\n  divSignal(other) {\n    assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n      operation: \"div\",\n      fault: \"divide-by-zero\",\n      value: this\n    });\n    this.#checkFormat(other);\n    const value = this.#val * this.#tens;\n    assert(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n      operation: \"divSignal\",\n      fault: \"underflow\",\n      value: this\n    });\n    return this.#checkValue(value / other.#val, \"divSignal\");\n  }\n  /**\n   *  Returns a comparison result between %%this%% and %%other%%.\n   *\n   *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n   *  both are equal.\n   */\n  cmp(other) {\n    let a = this.value,\n      b = other.value;\n    // Coerce a and b to the same magnitude\n    const delta = this.decimals - other.decimals;\n    if (delta > 0) {\n      b *= getTens(delta);\n    } else if (delta < 0) {\n      a *= getTens(-delta);\n    }\n    // Comnpare\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  }\n  /**\n   *  Returns true if %%other%% is equal to %%this%%.\n   */\n  eq(other) {\n    return this.cmp(other) === 0;\n  }\n  /**\n   *  Returns true if %%other%% is less than to %%this%%.\n   */\n  lt(other) {\n    return this.cmp(other) < 0;\n  }\n  /**\n   *  Returns true if %%other%% is less than or equal to %%this%%.\n   */\n  lte(other) {\n    return this.cmp(other) <= 0;\n  }\n  /**\n   *  Returns true if %%other%% is greater than to %%this%%.\n   */\n  gt(other) {\n    return this.cmp(other) > 0;\n  }\n  /**\n   *  Returns true if %%other%% is greater than or equal to %%this%%.\n   */\n  gte(other) {\n    return this.cmp(other) >= 0;\n  }\n  /**\n   *  Returns a new [[FixedNumber]] which is the largest **integer**\n   *  that is less than or equal to %%this%%.\n   *\n   *  The decimal component of the result will always be ``0``.\n   */\n  floor() {\n    let val = this.#val;\n    if (this.#val < BN_0) {\n      val -= this.#tens - BN_1;\n    }\n    val = this.#val / this.#tens * this.#tens;\n    return this.#checkValue(val, \"floor\");\n  }\n  /**\n   *  Returns a new [[FixedNumber]] which is the smallest **integer**\n   *  that is greater than or equal to %%this%%.\n   *\n   *  The decimal component of the result will always be ``0``.\n   */\n  ceiling() {\n    let val = this.#val;\n    if (this.#val > BN_0) {\n      val += this.#tens - BN_1;\n    }\n    val = this.#val / this.#tens * this.#tens;\n    return this.#checkValue(val, \"ceiling\");\n  }\n  /**\n   *  Returns a new [[FixedNumber]] with the decimal component\n   *  rounded up on ties at %%decimals%% places.\n   */\n  round(decimals) {\n    if (decimals == null) {\n      decimals = 0;\n    }\n    // Not enough precision to not already be rounded\n    if (decimals >= this.decimals) {\n      return this;\n    }\n    const delta = this.decimals - decimals;\n    const bump = BN_5 * getTens(delta - 1);\n    let value = this.value + bump;\n    const tens = getTens(delta);\n    value = value / tens * tens;\n    checkValue(value, this.#format, \"round\");\n    return new FixedNumber(_guard, value, this.#format);\n  }\n  /**\n   *  Returns true if %%this%% is equal to ``0``.\n   */\n  isZero() {\n    return this.#val === BN_0;\n  }\n  /**\n   *  Returns true if %%this%% is less than ``0``.\n   */\n  isNegative() {\n    return this.#val < BN_0;\n  }\n  /**\n   *  Returns the string representation of %%this%%.\n   */\n  toString() {\n    return this._value;\n  }\n  /**\n   *  Returns a float approximation.\n   *\n   *  Due to IEEE 754 precission (or lack thereof), this function\n   *  can only return an approximation and most values will contain\n   *  rounding errors.\n   */\n  toUnsafeFloat() {\n    return parseFloat(this.toString());\n  }\n  /**\n   *  Return a new [[FixedNumber]] with the same value but has had\n   *  its field set to %%format%%.\n   *\n   *  This will throw if the value cannot fit into %%format%%.\n   */\n  toFormat(format) {\n    return FixedNumber.fromString(this.toString(), format);\n  }\n  /**\n   *  Creates a new [[FixedNumber]] for %%value%% divided by\n   *  %%decimal%% places with %%format%%.\n   *\n   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n   *  or underflow (precision loss).\n   */\n  static fromValue(_value, _decimals, _format) {\n    const decimals = _decimals == null ? 0 : getNumber(_decimals);\n    const format = getFormat(_format);\n    let value = getBigInt(_value, \"value\");\n    const delta = decimals - format.decimals;\n    if (delta > 0) {\n      const tens = getTens(delta);\n      assert(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n        operation: \"fromValue\",\n        fault: \"underflow\",\n        value: _value\n      });\n      value /= tens;\n    } else if (delta < 0) {\n      value *= getTens(-delta);\n    }\n    checkValue(value, format, \"fromValue\");\n    return new FixedNumber(_guard, value, format);\n  }\n  /**\n   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n   *\n   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n   *  in %%format%%, either due to overflow or underflow (precision loss).\n   */\n  static fromString(_value, _format) {\n    const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n    assertArgument(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n    const format = getFormat(_format);\n    let whole = match[2] || \"0\",\n      decimal = match[3] || \"\";\n    // Pad out the decimals\n    while (decimal.length < format.decimals) {\n      decimal += Zeros;\n    }\n    // Check precision is safe\n    assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n      operation: \"fromString\",\n      fault: \"underflow\",\n      value: _value\n    });\n    // Remove extra padding\n    decimal = decimal.substring(0, format.decimals);\n    const value = BigInt(match[1] + whole + decimal);\n    checkValue(value, format, \"fromString\");\n    return new FixedNumber(_guard, value, format);\n  }\n  /**\n   *  Creates a new [[FixedNumber]] with the big-endian representation\n   *  %%value%% with %%format%%.\n   *\n   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n   *  in %%format%% due to overflow.\n   */\n  static fromBytes(_value, _format) {\n    let value = toBigInt(getBytes(_value, \"value\"));\n    const format = getFormat(_format);\n    if (format.signed) {\n      value = fromTwos(value, format.width);\n    }\n    checkValue(value, format, \"fromBytes\");\n    return new FixedNumber(_guard, value, format);\n  }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"names":["getBytes","assert","assertArgument","assertPrivate","getBigInt","getNumber","fromTwos","mask","toBigInt","defineProperties","BN_N1","BigInt","BN_0","BN_1","BN_5","_guard","Zeros","length","getTens","decimals","result","substring","checkValue","val","format","safeOp","width","signed","limit","operation","fault","value","getFormat","match","parseInt","v","check","key","type","defaultValue","name","String","toString","negative","str","index","FixedNumber","tens","_value","constructor","guard","checkFormat","#checkFormat","other","#checkValue","add","#add","o","addUnsafe","sub","#sub","subUnsafe","mul","#mul","mulUnsafe","mulSignal","div","#div","divUnsafe","divSignal","cmp","a","b","delta","eq","lt","lte","gt","gte","floor","ceiling","round","bump","isZero","isNegative","toUnsafeFloat","parseFloat","toFormat","fromString","fromValue","_decimals","_format","whole","decimal","fromBytes"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/utils/fixednumber.js"],"sourcesContent":["/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport { getBigInt, getNumber, fromTwos, mask, toBigInt } from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        }\n        else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            assertArgument(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        defineProperties(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        assertArgument(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : getNumber(_decimals);\n        const format = getFormat(_format);\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = fromTwos(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}