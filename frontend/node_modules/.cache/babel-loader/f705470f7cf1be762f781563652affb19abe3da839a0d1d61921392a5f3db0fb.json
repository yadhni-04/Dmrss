{"ast":null,"code":"import { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nexport class NonceManager extends AbstractSigner {\n  /**\n   *  The Signer being managed.\n   */\n  signer;\n  #noncePromise;\n  #delta;\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  constructor(signer) {\n    super(signer.provider);\n    defineProperties(this, {\n      signer\n    });\n    this.#noncePromise = null;\n    this.#delta = 0;\n  }\n  async getAddress() {\n    return this.signer.getAddress();\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  async getNonce(blockTag) {\n    if (blockTag === \"pending\") {\n      if (this.#noncePromise == null) {\n        this.#noncePromise = super.getNonce(\"pending\");\n      }\n      const delta = this.#delta;\n      return (await this.#noncePromise) + delta;\n    }\n    return super.getNonce(blockTag);\n  }\n  /**\n   *  Manually increment the nonce. This may be useful when managng\n   *  offline transactions.\n   */\n  increment() {\n    this.#delta++;\n  }\n  /**\n   *  Resets the nonce, causing the **NonceManager** to reload the current\n   *  nonce from the blockchain on the next transaction.\n   */\n  reset() {\n    this.#delta = 0;\n    this.#noncePromise = null;\n  }\n  async sendTransaction(tx) {\n    const noncePromise = this.getNonce(\"pending\");\n    this.increment();\n    tx = await this.signer.populateTransaction(tx);\n    tx.nonce = await noncePromise;\n    // @TODO: Maybe handle interesting/recoverable errors?\n    // Like don't increment if the tx was certainly not sent\n    return await this.signer.sendTransaction(tx);\n  }\n  signTransaction(tx) {\n    return this.signer.signTransaction(tx);\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n  }\n  signTypedData(domain, types, value) {\n    return this.signer.signTypedData(domain, types, value);\n  }\n}","map":{"version":3,"names":["defineProperties","AbstractSigner","NonceManager","signer","noncePromise","delta","constructor","provider","getAddress","connect","getNonce","blockTag","increment","reset","sendTransaction","tx","populateTransaction","nonce","signTransaction","signMessage","message","signTypedData","domain","types","value"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/providers/signer-noncemanager.js"],"sourcesContent":["import { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nexport class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer;\n    #noncePromise;\n    #delta;\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer) {\n        super(signer.provider);\n        defineProperties(this, { signer });\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n    async getAddress() {\n        return this.signer.getAddress();\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    async getNonce(blockTag) {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n        return super.getNonce(blockTag);\n    }\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment() {\n        this.#delta++;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset() {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n    async sendTransaction(tx) {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n    signTransaction(tx) {\n        return this.signer.signTransaction(tx);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n    signTypedData(domain, types, value) {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\n//# sourceMappingURL=signer-noncemanager.js.map"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,mBAAmB;AACpD,SAASC,cAAc,QAAQ,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,SAASD,cAAc,CAAC;EAC7C;AACJ;AACA;EACIE,MAAM;EACN,CAACC,YAAY;EACb,CAACC,KAAK;EACN;AACJ;AACA;EACIC,WAAWA,CAACH,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAACI,QAAQ,CAAC;IACtBP,gBAAgB,CAAC,IAAI,EAAE;MAAEG;IAAO,CAAC,CAAC;IAClC,IAAI,CAAC,CAACC,YAAY,GAAG,IAAI;IACzB,IAAI,CAAC,CAACC,KAAK,GAAG,CAAC;EACnB;EACA,MAAMG,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACL,MAAM,CAACK,UAAU,CAAC,CAAC;EACnC;EACAC,OAAOA,CAACF,QAAQ,EAAE;IACd,OAAO,IAAIL,YAAY,CAAC,IAAI,CAACC,MAAM,CAACM,OAAO,CAACF,QAAQ,CAAC,CAAC;EAC1D;EACA,MAAMG,QAAQA,CAACC,QAAQ,EAAE;IACrB,IAAIA,QAAQ,KAAK,SAAS,EAAE;MACxB,IAAI,IAAI,CAAC,CAACP,YAAY,IAAI,IAAI,EAAE;QAC5B,IAAI,CAAC,CAACA,YAAY,GAAG,KAAK,CAACM,QAAQ,CAAC,SAAS,CAAC;MAClD;MACA,MAAML,KAAK,GAAG,IAAI,CAAC,CAACA,KAAK;MACzB,OAAO,CAAC,MAAM,IAAI,CAAC,CAACD,YAAY,IAAIC,KAAK;IAC7C;IACA,OAAO,KAAK,CAACK,QAAQ,CAACC,QAAQ,CAAC;EACnC;EACA;AACJ;AACA;AACA;EACIC,SAASA,CAAA,EAAG;IACR,IAAI,CAAC,CAACP,KAAK,EAAE;EACjB;EACA;AACJ;AACA;AACA;EACIQ,KAAKA,CAAA,EAAG;IACJ,IAAI,CAAC,CAACR,KAAK,GAAG,CAAC;IACf,IAAI,CAAC,CAACD,YAAY,GAAG,IAAI;EAC7B;EACA,MAAMU,eAAeA,CAACC,EAAE,EAAE;IACtB,MAAMX,YAAY,GAAG,IAAI,CAACM,QAAQ,CAAC,SAAS,CAAC;IAC7C,IAAI,CAACE,SAAS,CAAC,CAAC;IAChBG,EAAE,GAAG,MAAM,IAAI,CAACZ,MAAM,CAACa,mBAAmB,CAACD,EAAE,CAAC;IAC9CA,EAAE,CAACE,KAAK,GAAG,MAAMb,YAAY;IAC7B;IACA;IACA,OAAO,MAAM,IAAI,CAACD,MAAM,CAACW,eAAe,CAACC,EAAE,CAAC;EAChD;EACAG,eAAeA,CAACH,EAAE,EAAE;IAChB,OAAO,IAAI,CAACZ,MAAM,CAACe,eAAe,CAACH,EAAE,CAAC;EAC1C;EACAI,WAAWA,CAACC,OAAO,EAAE;IACjB,OAAO,IAAI,CAACjB,MAAM,CAACgB,WAAW,CAACC,OAAO,CAAC;EAC3C;EACAC,aAAaA,CAACC,MAAM,EAAEC,KAAK,EAAEC,KAAK,EAAE;IAChC,OAAO,IAAI,CAACrB,MAAM,CAACkB,aAAa,CAACC,MAAM,EAAEC,KAAK,EAAEC,KAAK,CAAC;EAC1D;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}