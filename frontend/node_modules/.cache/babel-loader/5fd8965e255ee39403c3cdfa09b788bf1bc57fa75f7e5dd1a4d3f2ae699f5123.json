{"ast":null,"code":"import { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\nimport { SocketProvider } from \"./provider-socket.js\";\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nexport class WebSocketProvider extends SocketProvider {\n  #connect;\n  #websocket;\n  get websocket() {\n    if (this.#websocket == null) {\n      throw new Error(\"websocket closed\");\n    }\n    return this.#websocket;\n  }\n  constructor(url, network, options) {\n    super(network, options);\n    if (typeof url === \"string\") {\n      this.#connect = () => {\n        return new _WebSocket(url);\n      };\n      this.#websocket = this.#connect();\n    } else if (typeof url === \"function\") {\n      this.#connect = url;\n      this.#websocket = url();\n    } else {\n      this.#connect = null;\n      this.#websocket = url;\n    }\n    this.websocket.onopen = async () => {\n      try {\n        await this._start();\n        this.resume();\n      } catch (error) {\n        console.log(\"failed to start WebsocketProvider\", error);\n        // @TODO: now what? Attempt reconnect?\n      }\n    };\n    this.websocket.onmessage = message => {\n      this._processMessage(message.data);\n    };\n    /*\n            this.websocket.onclose = (event) => {\n                // @TODO: What event.code should we reconnect on?\n                const reconnect = false;\n                if (reconnect) {\n                    this.pause(true);\n                    if (this.#connect) {\n                        this.#websocket = this.#connect();\n                        this.#websocket.onopen = ...\n                        // @TODO: this requires the super class to rebroadcast; move it there\n                    }\n                    this._reconnect();\n                }\n            };\n    */\n  }\n  async _write(message) {\n    this.websocket.send(message);\n  }\n  async destroy() {\n    if (this.#websocket != null) {\n      this.#websocket.close();\n      this.#websocket = null;\n    }\n    super.destroy();\n  }\n}","map":{"version":3,"names":["WebSocket","_WebSocket","SocketProvider","WebSocketProvider","connect","websocket","Error","constructor","url","network","options","onopen","_start","resume","error","console","log","onmessage","message","_processMessage","data","_write","send","destroy","close"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/providers/provider-websocket.js"],"sourcesContent":["import { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\nimport { SocketProvider } from \"./provider-socket.js\";\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nexport class WebSocketProvider extends SocketProvider {\n    #connect;\n    #websocket;\n    get websocket() {\n        if (this.#websocket == null) {\n            throw new Error(\"websocket closed\");\n        }\n        return this.#websocket;\n    }\n    constructor(url, network, options) {\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = () => { return new _WebSocket(url); };\n            this.#websocket = this.#connect();\n        }\n        else if (typeof (url) === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        }\n        else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n        this.websocket.onopen = async () => {\n            try {\n                await this._start();\n                this.resume();\n            }\n            catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n                // @TODO: now what? Attempt reconnect?\n            }\n        };\n        this.websocket.onmessage = (message) => {\n            this._processMessage(message.data);\n        };\n        /*\n                this.websocket.onclose = (event) => {\n                    // @TODO: What event.code should we reconnect on?\n                    const reconnect = false;\n                    if (reconnect) {\n                        this.pause(true);\n                        if (this.#connect) {\n                            this.#websocket = this.#connect();\n                            this.#websocket.onopen = ...\n                            // @TODO: this requires the super class to rebroadcast; move it there\n                        }\n                        this._reconnect();\n                    }\n                };\n        */\n    }\n    async _write(message) {\n        this.websocket.send(message);\n    }\n    async destroy() {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-websocket.js.map"],"mappings":"AAAA,SAASA,SAAS,IAAIC,UAAU,QAAQ,SAAS,CAAC,CAAC;AACnD,SAASC,cAAc,QAAQ,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,SAASD,cAAc,CAAC;EAClD,CAACE,OAAO;EACR,CAACC,SAAS;EACV,IAAIA,SAASA,CAAA,EAAG;IACZ,IAAI,IAAI,CAAC,CAACA,SAAS,IAAI,IAAI,EAAE;MACzB,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,OAAO,IAAI,CAAC,CAACD,SAAS;EAC1B;EACAE,WAAWA,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC/B,KAAK,CAACD,OAAO,EAAEC,OAAO,CAAC;IACvB,IAAI,OAAQF,GAAI,KAAK,QAAQ,EAAE;MAC3B,IAAI,CAAC,CAACJ,OAAO,GAAG,MAAM;QAAE,OAAO,IAAIH,UAAU,CAACO,GAAG,CAAC;MAAE,CAAC;MACrD,IAAI,CAAC,CAACH,SAAS,GAAG,IAAI,CAAC,CAACD,OAAO,CAAC,CAAC;IACrC,CAAC,MACI,IAAI,OAAQI,GAAI,KAAK,UAAU,EAAE;MAClC,IAAI,CAAC,CAACJ,OAAO,GAAGI,GAAG;MACnB,IAAI,CAAC,CAACH,SAAS,GAAGG,GAAG,CAAC,CAAC;IAC3B,CAAC,MACI;MACD,IAAI,CAAC,CAACJ,OAAO,GAAG,IAAI;MACpB,IAAI,CAAC,CAACC,SAAS,GAAGG,GAAG;IACzB;IACA,IAAI,CAACH,SAAS,CAACM,MAAM,GAAG,YAAY;MAChC,IAAI;QACA,MAAM,IAAI,CAACC,MAAM,CAAC,CAAC;QACnB,IAAI,CAACC,MAAM,CAAC,CAAC;MACjB,CAAC,CACD,OAAOC,KAAK,EAAE;QACVC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAEF,KAAK,CAAC;QACvD;MACJ;IACJ,CAAC;IACD,IAAI,CAACT,SAAS,CAACY,SAAS,GAAIC,OAAO,IAAK;MACpC,IAAI,CAACC,eAAe,CAACD,OAAO,CAACE,IAAI,CAAC;IACtC,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;EACA,MAAMC,MAAMA,CAACH,OAAO,EAAE;IAClB,IAAI,CAACb,SAAS,CAACiB,IAAI,CAACJ,OAAO,CAAC;EAChC;EACA,MAAMK,OAAOA,CAAA,EAAG;IACZ,IAAI,IAAI,CAAC,CAAClB,SAAS,IAAI,IAAI,EAAE;MACzB,IAAI,CAAC,CAACA,SAAS,CAACmB,KAAK,CAAC,CAAC;MACvB,IAAI,CAAC,CAACnB,SAAS,GAAG,IAAI;IAC1B;IACA,KAAK,CAACkB,OAAO,CAAC,CAAC;EACnB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}