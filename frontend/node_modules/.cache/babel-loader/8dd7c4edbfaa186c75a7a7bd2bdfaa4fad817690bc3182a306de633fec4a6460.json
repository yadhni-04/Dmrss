{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { authorizationify } from \"./authorization.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n  const blobToKzgCommitment = blob => {\n    if (\"computeBlobProof\" in kzg) {\n      // micro-ecc-signer; check for computeBlobProof since this API\n      // expects a string while the kzg-wasm below expects a Unit8Array\n      if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));\n      }\n    } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n      // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n      return getBytes(kzg.blobToKzgCommitment(blob));\n    }\n    // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n    if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  const computeBlobKzgProof = (blob, commitment) => {\n    // micro-ecc-signer\n    if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));\n    }\n    // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n    if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n      return kzg.computeBlobKzgProof(blob, commitment);\n    }\n    // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n    if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  return {\n    blobToKzgCommitment,\n    computeBlobKzgProof\n  };\n}\nfunction getVersionedHash(version, hash) {\n  let versioned = version.toString(16);\n  while (versioned.length < 2) {\n    versioned = \"0\" + versioned;\n  }\n  versioned += sha256(hash).substring(4);\n  return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleAuthorizationList(value, param) {\n  try {\n    if (!Array.isArray(value)) {\n      throw new Error(\"authorizationList: invalid array\");\n    }\n    const result = [];\n    for (let i = 0; i < value.length; i++) {\n      const auth = value[i];\n      if (!Array.isArray(auth)) {\n        throw new Error(`authorization[${i}]: invalid array`);\n      }\n      if (auth.length !== 6) {\n        throw new Error(`authorization[${i}]: wrong length`);\n      }\n      if (!auth[1]) {\n        throw new Error(`authorization[${i}]: null address`);\n      }\n      result.push({\n        address: handleAddress(auth[1]),\n        nonce: handleUint(auth[2], \"nonce\"),\n        chainId: handleUint(auth[0], \"chainId\"),\n        signature: Signature.from({\n          yParity: handleNumber(auth[3], \"yParity\"),\n          r: zeroPadValue(auth[4], 32),\n          s: zeroPadValue(auth[5], 32)\n        })\n      });\n    }\n    return result;\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  const value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  const value = getBigInt(_value, \"value\");\n  const result = toBeArray(value);\n  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n  return value.map(a => {\n    return [formatNumber(a.chainId, \"chainId\"), a.address, formatNumber(a.nonce, \"nonce\"), formatNumber(a.signature.yParity, \"yParity\"), toBeArray(a.signature.r), toBeArray(a.signature.s)];\n  });\n}\nfunction formatHashes(value, param) {\n  assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n  for (let i = 0; i < value.length; i++) {\n    assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n  }\n  return value;\n}\nfunction _parseLegacy(data) {\n  const fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  const tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  const v = handleUint(fields[6], \"v\");\n  const r = handleUint(fields[7], \"r\");\n  const s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    let chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v\n    });\n    //tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  const fields = [formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data];\n  let chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    const legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  let v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  let yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  const r = zeroPadValue(fields[1], 32);\n  const s = zeroPadValue(fields[2], 32);\n  const signature = Signature.from({\n    r,\n    s,\n    yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  const tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  const tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n  let fields = decodeRlp(getBytes(data).slice(1));\n  let typeName = \"3\";\n  let blobs = null;\n  // Parse the network format\n  if (fields.length === 4 && Array.isArray(fields[0])) {\n    typeName = \"3 (network format)\";\n    const fBlobs = fields[1],\n      fCommits = fields[2],\n      fProofs = fields[3];\n    assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n    assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n    assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n    assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n    assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n    blobs = [];\n    for (let i = 0; i < fields[1].length; i++) {\n      blobs.push({\n        data: fBlobs[i],\n        commitment: fCommits[i],\n        proof: fProofs[i]\n      });\n    }\n    fields = fields[0];\n  }\n  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", hexlify(data));\n  const tx = {\n    type: 3,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n    blobVersionedHashes: fields[10]\n  };\n  if (blobs) {\n    tx.blobs = blobs;\n  }\n  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n  assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n  }\n  // Unsigned EIP-4844 Transaction\n  if (fields.length === 11) {\n    return tx;\n  }\n  // @TODO: Do we need to do this? This is only called internally\n  // and used to verify hashes; it might save time to not do this\n  //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n  _parseEipSignature(tx, fields.slice(11));\n  return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || ZeroAddress, formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"), formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    // We have blobs; return the network wrapped format\n    if (blobs) {\n      return concat([\"0x03\", encodeRlp([fields, blobs.map(b => b.data), blobs.map(b => b.commitment), blobs.map(b => b.proof)])]);\n    }\n  }\n  return concat([\"0x03\", encodeRlp(fields)]);\n}\nfunction _parseEip7702(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", hexlify(data));\n  const tx = {\n    type: 4,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n  };\n  // Unsigned EIP-7702 Transaction\n  if (fields.length === 10) {\n    return tx;\n  }\n  _parseEipSignature(tx, fields.slice(10));\n  return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatAuthorizationList(tx.authorizationList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x04\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n  #type;\n  #to;\n  #data;\n  #nonce;\n  #gasLimit;\n  #gasPrice;\n  #maxPriorityFeePerGas;\n  #maxFeePerGas;\n  #value;\n  #chainId;\n  #sig;\n  #accessList;\n  #maxFeePerBlobGas;\n  #blobVersionedHashes;\n  #kzg;\n  #blobs;\n  #auths;\n  /**\n   *  The transaction type.\n   *\n   *  If null, the type will be automatically inferred based on\n   *  explicit properties.\n   */\n  get type() {\n    return this.#type;\n  }\n  set type(value) {\n    switch (value) {\n      case null:\n        this.#type = null;\n        break;\n      case 0:\n      case \"legacy\":\n        this.#type = 0;\n        break;\n      case 1:\n      case \"berlin\":\n      case \"eip-2930\":\n        this.#type = 1;\n        break;\n      case 2:\n      case \"london\":\n      case \"eip-1559\":\n        this.#type = 2;\n        break;\n      case 3:\n      case \"cancun\":\n      case \"eip-4844\":\n        this.#type = 3;\n        break;\n      case 4:\n      case \"pectra\":\n      case \"eip-7702\":\n        this.#type = 4;\n        break;\n      default:\n        assertArgument(false, \"unsupported transaction type\", \"type\", value);\n    }\n  }\n  /**\n   *  The name of the transaction type.\n   */\n  get typeName() {\n    switch (this.type) {\n      case 0:\n        return \"legacy\";\n      case 1:\n        return \"eip-2930\";\n      case 2:\n        return \"eip-1559\";\n      case 3:\n        return \"eip-4844\";\n      case 4:\n        return \"eip-7702\";\n    }\n    return null;\n  }\n  /**\n   *  The ``to`` address for the transaction or ``null`` if the\n   *  transaction is an ``init`` transaction.\n   */\n  get to() {\n    const value = this.#to;\n    if (value == null && this.type === 3) {\n      return ZeroAddress;\n    }\n    return value;\n  }\n  set to(value) {\n    this.#to = value == null ? null : getAddress(value);\n  }\n  /**\n   *  The transaction nonce.\n   */\n  get nonce() {\n    return this.#nonce;\n  }\n  set nonce(value) {\n    this.#nonce = getNumber(value, \"value\");\n  }\n  /**\n   *  The gas limit.\n   */\n  get gasLimit() {\n    return this.#gasLimit;\n  }\n  set gasLimit(value) {\n    this.#gasLimit = getBigInt(value);\n  }\n  /**\n   *  The gas price.\n   *\n   *  On legacy networks this defines the fee that will be paid. On\n   *  EIP-1559 networks, this should be ``null``.\n   */\n  get gasPrice() {\n    const value = this.#gasPrice;\n    if (value == null && (this.type === 0 || this.type === 1)) {\n      return BN_0;\n    }\n    return value;\n  }\n  set gasPrice(value) {\n    this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\");\n  }\n  /**\n   *  The maximum priority fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxPriorityFeePerGas() {\n    const value = this.#maxPriorityFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxPriorityFeePerGas(value) {\n    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n  }\n  /**\n   *  The maximum total fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxFeePerGas() {\n    const value = this.#maxFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxFeePerGas(value) {\n    this.#maxFeePerGas = value == null ? null : getBigInt(value, \"maxFeePerGas\");\n  }\n  /**\n   *  The transaction data. For ``init`` transactions this is the\n   *  deployment code.\n   */\n  get data() {\n    return this.#data;\n  }\n  set data(value) {\n    this.#data = hexlify(value);\n  }\n  /**\n   *  The amount of ether (in wei) to send in this transactions.\n   */\n  get value() {\n    return this.#value;\n  }\n  set value(value) {\n    this.#value = getBigInt(value, \"value\");\n  }\n  /**\n   *  The chain ID this transaction is valid on.\n   */\n  get chainId() {\n    return this.#chainId;\n  }\n  set chainId(value) {\n    this.#chainId = getBigInt(value);\n  }\n  /**\n   *  If signed, the signature for this transaction.\n   */\n  get signature() {\n    return this.#sig || null;\n  }\n  set signature(value) {\n    this.#sig = value == null ? null : Signature.from(value);\n  }\n  /**\n   *  The access list.\n   *\n   *  An access list permits discounted (but pre-paid) access to\n   *  bytecode and state variable access within contract execution.\n   */\n  get accessList() {\n    const value = this.#accessList || null;\n    if (value == null) {\n      if (this.type === 1 || this.type === 2 || this.type === 3) {\n        // @TODO: in v7, this should assign the value or become\n        // a live object itself, otherwise mutation is inconsistent\n        return [];\n      }\n      return null;\n    }\n    return value;\n  }\n  set accessList(value) {\n    this.#accessList = value == null ? null : accessListify(value);\n  }\n  get authorizationList() {\n    const value = this.#auths || null;\n    if (value == null) {\n      if (this.type === 4) {\n        // @TODO: in v7, this should become a live object itself,\n        // otherwise mutation is inconsistent\n        return [];\n      }\n    }\n    return value;\n  }\n  set authorizationList(auths) {\n    this.#auths = auths == null ? null : auths.map(a => authorizationify(a));\n  }\n  /**\n   *  The max fee per blob gas for Cancun transactions.\n   */\n  get maxFeePerBlobGas() {\n    const value = this.#maxFeePerBlobGas;\n    if (value == null && this.type === 3) {\n      return BN_0;\n    }\n    return value;\n  }\n  set maxFeePerBlobGas(value) {\n    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, \"maxFeePerBlobGas\");\n  }\n  /**\n   *  The BLOb versioned hashes for Cancun transactions.\n   */\n  get blobVersionedHashes() {\n    // @TODO: Mutation is inconsistent; if unset, the returned value\n    // cannot mutate the object, if set it can\n    let value = this.#blobVersionedHashes;\n    if (value == null && this.type === 3) {\n      return [];\n    }\n    return value;\n  }\n  set blobVersionedHashes(value) {\n    if (value != null) {\n      assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n      value = value.slice();\n      for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n      }\n    }\n    this.#blobVersionedHashes = value;\n  }\n  /**\n   *  The BLObs for the Transaction, if any.\n   *\n   *  If ``blobs`` is non-``null``, then the [[seriailized]]\n   *  will return the network formatted sidecar, otherwise it\n   *  will return the standard [[link-eip-2718]] payload. The\n   *  [[unsignedSerialized]] is unaffected regardless.\n   *\n   *  When setting ``blobs``, either fully valid [[Blob]] objects\n   *  may be specified (i.e. correctly padded, with correct\n   *  committments and proofs) or a raw [[BytesLike]] may\n   *  be provided.\n   *\n   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n   *  be already set. The blob will be correctly padded and the\n   *  [[KzgLibrary]] will be used to compute the committment and\n   *  proof for the blob.\n   *\n   *  A BLOb is a sequence of field elements, each of which must\n   *  be within the BLS field modulo, so some additional processing\n   *  may be required to encode arbitrary data to ensure each 32 byte\n   *  field is within the valid range.\n   *\n   *  Setting this automatically populates [[blobVersionedHashes]],\n   *  overwriting any existing values. Setting this to ``null``\n   *  does **not** remove the [[blobVersionedHashes]], leaving them\n   *  present.\n   */\n  get blobs() {\n    if (this.#blobs == null) {\n      return null;\n    }\n    return this.#blobs.map(b => Object.assign({}, b));\n  }\n  set blobs(_blobs) {\n    if (_blobs == null) {\n      this.#blobs = null;\n      return;\n    }\n    const blobs = [];\n    const versionedHashes = [];\n    for (let i = 0; i < _blobs.length; i++) {\n      const blob = _blobs[i];\n      if (isBytesLike(blob)) {\n        assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"set blobs()\"\n        });\n        let data = getBytes(blob);\n        assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n        // Pad blob if necessary\n        if (data.length !== BLOB_SIZE) {\n          const padded = new Uint8Array(BLOB_SIZE);\n          padded.set(data);\n          data = padded;\n        }\n        const commit = this.#kzg.blobToKzgCommitment(data);\n        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n        blobs.push({\n          data: hexlify(data),\n          commitment: hexlify(commit),\n          proof\n        });\n        versionedHashes.push(getVersionedHash(1, commit));\n      } else {\n        const commit = hexlify(blob.commitment);\n        blobs.push({\n          data: hexlify(blob.data),\n          commitment: commit,\n          proof: hexlify(blob.proof)\n        });\n        versionedHashes.push(getVersionedHash(1, commit));\n      }\n    }\n    this.#blobs = blobs;\n    this.#blobVersionedHashes = versionedHashes;\n  }\n  get kzg() {\n    return this.#kzg;\n  }\n  set kzg(kzg) {\n    if (kzg == null) {\n      this.#kzg = null;\n    } else {\n      this.#kzg = getKzgLibrary(kzg);\n    }\n  }\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  constructor() {\n    this.#type = null;\n    this.#to = null;\n    this.#nonce = 0;\n    this.#gasLimit = BN_0;\n    this.#gasPrice = null;\n    this.#maxPriorityFeePerGas = null;\n    this.#maxFeePerGas = null;\n    this.#data = \"0x\";\n    this.#value = BN_0;\n    this.#chainId = BN_0;\n    this.#sig = null;\n    this.#accessList = null;\n    this.#maxFeePerBlobGas = null;\n    this.#blobVersionedHashes = null;\n    this.#kzg = null;\n    this.#blobs = null;\n    this.#auths = null;\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  get hash() {\n    if (this.signature == null) {\n      return null;\n    }\n    return keccak256(this.#getSerialized(true, false));\n  }\n  /**\n   *  The pre-image hash of this transaction.\n   *\n   *  This is the digest that a [[Signer]] must sign to authorize\n   *  this transaction.\n   */\n  get unsignedHash() {\n    return keccak256(this.unsignedSerialized);\n  }\n  /**\n   *  The sending address, if signed. Otherwise, ``null``.\n   */\n  get from() {\n    if (this.signature == null) {\n      return null;\n    }\n    return recoverAddress(this.unsignedHash, this.signature);\n  }\n  /**\n   *  The public key of the sender, if signed. Otherwise, ``null``.\n   */\n  get fromPublicKey() {\n    if (this.signature == null) {\n      return null;\n    }\n    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n  }\n  /**\n   *  Returns true if signed.\n   *\n   *  This provides a Type Guard that properties requiring a signed\n   *  transaction are non-null.\n   */\n  isSigned() {\n    return this.signature != null;\n  }\n  #getSerialized(signed, sidecar) {\n    assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n    const sig = signed ? this.signature : null;\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this, sig);\n      case 1:\n        return _serializeEip2930(this, sig);\n      case 2:\n        return _serializeEip1559(this, sig);\n      case 3:\n        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n      case 4:\n        return _serializeEip7702(this, sig);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n  }\n  /**\n   *  The serialized transaction.\n   *\n   *  This throws if the transaction is unsigned. For the pre-image,\n   *  use [[unsignedSerialized]].\n   */\n  get serialized() {\n    return this.#getSerialized(true, true);\n  }\n  /**\n   *  The transaction pre-image.\n   *\n   *  The hash of this is the digest which needs to be signed to\n   *  authorize this transaction.\n   */\n  get unsignedSerialized() {\n    return this.#getSerialized(false, false);\n  }\n  /**\n   *  Return the most \"likely\" type; currently the highest\n   *  supported transaction type.\n   */\n  inferType() {\n    const types = this.inferTypes();\n    // Prefer London (EIP-1559) over Cancun (BLOb)\n    if (types.indexOf(2) >= 0) {\n      return 2;\n    }\n    // Return the highest inferred type\n    return types.pop();\n  }\n  /**\n   *  Validates the explicit properties and returns a list of compatible\n   *  transaction types.\n   */\n  inferTypes() {\n    // Checks that there are no conflicting properties set\n    const hasGasPrice = this.gasPrice != null;\n    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n    const hasAccessList = this.accessList != null;\n    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;\n    //if (hasGasPrice && hasFee) {\n    //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n    //}\n    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n        value: this\n      });\n    }\n    //if (this.type === 2 && hasGasPrice) {\n    //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n    //}\n    assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n      value: this\n    });\n    assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n      value: this\n    });\n    const types = [];\n    // Explicit type\n    if (this.type != null) {\n      types.push(this.type);\n    } else {\n      if (this.authorizationList && this.authorizationList.length) {\n        types.push(4);\n      } else if (hasFee) {\n        types.push(2);\n      } else if (hasGasPrice) {\n        types.push(1);\n        if (!hasAccessList) {\n          types.push(0);\n        }\n      } else if (hasAccessList) {\n        types.push(1);\n        types.push(2);\n      } else if (hasBlob && this.to) {\n        types.push(3);\n      } else {\n        types.push(0);\n        types.push(1);\n        types.push(2);\n        types.push(3);\n      }\n    }\n    types.sort();\n    return types;\n  }\n  /**\n   *  Returns true if this transaction is a legacy transaction (i.e.\n   *  ``type === 0``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if this transaction is berlin hardform transaction (i.e.\n   *  ``type === 1``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if this transaction is london hardform transaction (i.e.\n   *  ``type === 2``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n   *  transaction.\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isCancun() {\n    return this.type === 3;\n  }\n  /**\n   *  Create a copy of this transaciton.\n   */\n  clone() {\n    return Transaction.from(this);\n  }\n  /**\n   *  Return a JSON-friendly object.\n   */\n  toJSON() {\n    const s = v => {\n      if (v == null) {\n        return null;\n      }\n      return v.toString();\n    };\n    return {\n      type: this.type,\n      to: this.to,\n      //            from: this.from,\n      data: this.data,\n      nonce: this.nonce,\n      gasLimit: s(this.gasLimit),\n      gasPrice: s(this.gasPrice),\n      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n      maxFeePerGas: s(this.maxFeePerGas),\n      value: s(this.value),\n      chainId: s(this.chainId),\n      sig: this.signature ? this.signature.toJSON() : null,\n      accessList: this.accessList\n    };\n  }\n  /**\n   *  Create a **Transaction** from a serialized transaction or a\n   *  Transaction-like object.\n   */\n  static from(tx) {\n    if (tx == null) {\n      return new Transaction();\n    }\n    if (typeof tx === \"string\") {\n      const payload = getBytes(tx);\n      if (payload[0] >= 0x7f) {\n        // @TODO: > vs >= ??\n        return Transaction.from(_parseLegacy(payload));\n      }\n      switch (payload[0]) {\n        case 1:\n          return Transaction.from(_parseEip2930(payload));\n        case 2:\n          return Transaction.from(_parseEip1559(payload));\n        case 3:\n          return Transaction.from(_parseEip4844(payload));\n        case 4:\n          return Transaction.from(_parseEip7702(payload));\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"from\"\n      });\n    }\n    const result = new Transaction();\n    if (tx.type != null) {\n      result.type = tx.type;\n    }\n    if (tx.to != null) {\n      result.to = tx.to;\n    }\n    if (tx.nonce != null) {\n      result.nonce = tx.nonce;\n    }\n    if (tx.gasLimit != null) {\n      result.gasLimit = tx.gasLimit;\n    }\n    if (tx.gasPrice != null) {\n      result.gasPrice = tx.gasPrice;\n    }\n    if (tx.maxPriorityFeePerGas != null) {\n      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n    }\n    if (tx.maxFeePerGas != null) {\n      result.maxFeePerGas = tx.maxFeePerGas;\n    }\n    if (tx.maxFeePerBlobGas != null) {\n      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n    }\n    if (tx.data != null) {\n      result.data = tx.data;\n    }\n    if (tx.value != null) {\n      result.value = tx.value;\n    }\n    if (tx.chainId != null) {\n      result.chainId = tx.chainId;\n    }\n    if (tx.signature != null) {\n      result.signature = Signature.from(tx.signature);\n    }\n    if (tx.accessList != null) {\n      result.accessList = tx.accessList;\n    }\n    if (tx.authorizationList != null) {\n      result.authorizationList = tx.authorizationList;\n    }\n    // This will get overwritten by blobs, if present\n    if (tx.blobVersionedHashes != null) {\n      result.blobVersionedHashes = tx.blobVersionedHashes;\n    }\n    // Make sure we assign the kzg before assigning blobs, which\n    // require the library in the event raw blob data is provided.\n    if (tx.kzg != null) {\n      result.kzg = tx.kzg;\n    }\n    if (tx.blobs != null) {\n      result.blobs = tx.blobs;\n    }\n    if (tx.hash != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n      assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n    }\n    if (tx.from != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n      assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["getAddress","ZeroAddress","keccak256","sha256","Signature","SigningKey","concat","decodeRlp","encodeRlp","getBytes","getBigInt","getNumber","hexlify","assert","assertArgument","isBytesLike","isHexString","toBeArray","zeroPadValue","accessListify","authorizationify","recoverAddress","BN_0","BigInt","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","BLOB_SIZE","getKzgLibrary","kzg","blobToKzgCommitment","blob","blobToKZGCommitment","computeBlobKzgProof","commitment","computeBlobProof","computeBlobKZGProof","getVersionedHash","version","hash","versioned","toString","length","substring","handleAddress","value","handleAccessList","param","error","message","handleAuthorizationList","Array","isArray","Error","result","i","auth","push","address","nonce","handleUint","chainId","signature","from","yParity","handleNumber","r","s","_value","formatNumber","name","formatAccessList","map","set","storageKeys","formatAuthorizationList","a","formatHashes","_parseLegacy","data","fields","tx","type","gasPrice","gasLimit","to","v","_serializeLegacy","sig","networkV","legacyChainId","legacy","getChainIdV","_parseEipSignature","_parseEip1559","slice","maxPriorityFeePerGas","maxFeePerGas","accessList","_serializeEip1559","_parseEip2930","_serializeEip2930","_parseEip4844","typeName","blobs","fBlobs","fCommits","fProofs","proof","maxFeePerBlobGas","blobVersionedHashes","_serializeEip4844","b","_parseEip7702","authorizationList","_serializeEip7702","Transaction","auths","Object","assign","_blobs","versionedHashes","operation","padded","Uint8Array","commit","constructor","getSerialized","unsignedHash","unsignedSerialized","fromPublicKey","recoverPublicKey","isSigned","#getSerialized","signed","sidecar","inferType","serialized","types","inferTypes","indexOf","pop","hasGasPrice","hasFee","hasAccessList","hasBlob","sort","isLegacy","isBerlin","isLondon","isCancun","clone","toJSON","payload","toLowerCase"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/transaction/transaction.js"],"sourcesContent":["import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { authorizationify } from \"./authorization.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob) => {\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n                return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));\n            }\n        }\n        else if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return getBytes(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof (kzg.blobToKZGCommitment) === \"function\") {\n            return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));\n        }\n        assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment) => {\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof (kzg.computeBlobProof) === \"function\") {\n            return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof (kzg.computeBlobKzgProof) === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof (kzg.computeBlobKZGProof) === \"function\") {\n            return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));\n        }\n        assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return { blobToKzgCommitment, computeBlobKzgProof };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) {\n        versioned = \"0\" + versioned;\n    }\n    versioned += sha256(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return accessListify(value);\n    }\n    catch (error) {\n        assertArgument(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i++) {\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(`authorization[${i}]: invalid array`);\n            }\n            if (auth.length !== 6) {\n                throw new Error(`authorization[${i}]: wrong length`);\n            }\n            if (!auth[1]) {\n                throw new Error(`authorization[${i}]: null address`);\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: zeroPadValue(auth[4], 32),\n                    s: zeroPadValue(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    }\n    catch (error) {\n        assertArgument(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a) => {\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            toBeArray(a.signature.r),\n            toBeArray(a.signature.s)\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = decodeRlp(data);\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: hexlify(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n        //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return encodeRlp(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n    let fields = decodeRlp(getBytes(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n        fields = fields[0];\n    }\n    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", hexlify(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return concat([\n                \"0x03\",\n                encodeRlp([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n        }\n    }\n    return concat([\"0x03\", encodeRlp(fields)]);\n}\nfunction _parseEip7702(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", hexlify(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\"),\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x04\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    #auths;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n            case 4: return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : getAddress(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = getNumber(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = getBigInt(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : getBigInt(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : getBigInt(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = hexlify(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = getBigInt(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = getBigInt(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : accessListify(value);\n    }\n    get authorizationList() {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        this.#auths = (auths == null) ? null : auths.map((a) => authorizationify(a));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : getBigInt(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b) => Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n            if (isBytesLike(blob)) {\n                assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = getBytes(blob);\n                assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: hexlify(data),\n                    commitment: hexlify(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n            else {\n                const commit = hexlify(blob.commitment);\n                blobs.push({\n                    data: hexlify(blob.data),\n                    commitment: commit,\n                    proof: hexlify(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() { return this.#kzg; }\n    set kzg(kzg) {\n        if (kzg == null) {\n            this.#kzg = null;\n        }\n        else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return keccak256(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        const sig = signed ? this.signature : null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            }\n            else if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = getBytes(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n                case 4: return Transaction.from(_parseEip7702(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}