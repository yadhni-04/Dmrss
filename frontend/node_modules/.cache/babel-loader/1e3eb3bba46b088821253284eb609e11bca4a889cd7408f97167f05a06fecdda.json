{"ast":null,"code":"/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nimport { CBC, pkcs7Strip } from \"aes-js\";\nimport { getAddress } from \"../address/index.js\";\nimport { pbkdf2 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nimport { getPassword, looseArrayify, spelunk } from \"./utils.js\";\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nexport function isCrowdsaleJson(json) {\n  try {\n    const data = JSON.parse(json);\n    if (data.encseed) {\n      return true;\n    }\n  } catch (error) {}\n  return false;\n}\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nexport function decryptCrowdsaleJson(json, _password) {\n  const data = JSON.parse(json);\n  const password = getPassword(_password);\n  // Ethereum Address\n  const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n  // Encrypted Seed\n  const encseed = looseArrayify(spelunk(data, \"encseed:string!\"));\n  assertArgument(encseed && encseed.length % 16 === 0, \"invalid encseed\", \"json\", json);\n  const key = getBytes(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n  const iv = encseed.slice(0, 16);\n  const encryptedSeed = encseed.slice(16);\n  // Decrypt the seed\n  const aesCbc = new CBC(key, iv);\n  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));\n  // This wallet format is weird... Convert the binary encoded hex to a string.\n  let seedHex = \"\";\n  for (let i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n  return {\n    address,\n    privateKey: id(seedHex)\n  };\n}","map":{"version":3,"names":["CBC","pkcs7Strip","getAddress","pbkdf2","id","getBytes","assertArgument","getPassword","looseArrayify","spelunk","isCrowdsaleJson","json","data","JSON","parse","encseed","error","decryptCrowdsaleJson","_password","password","address","length","key","slice","iv","encryptedSeed","aesCbc","seed","decrypt","seedHex","i","String","fromCharCode","privateKey"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/wallet/json-crowdsale.js"],"sourcesContent":["/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nimport { CBC, pkcs7Strip } from \"aes-js\";\nimport { getAddress } from \"../address/index.js\";\nimport { pbkdf2 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nimport { getPassword, looseArrayify, spelunk } from \"./utils.js\";\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nexport function isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nexport function decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = looseArrayify(spelunk(data, \"encseed:string!\"));\n    assertArgument(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\n    const key = getBytes(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new CBC(key, iv);\n    const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return { address, privateKey: id(seedHex) };\n}\n//# sourceMappingURL=json-crowdsale.js.map"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,GAAG,EAAEC,UAAU,QAAQ,QAAQ;AACxC,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,EAAE,QAAQ,kBAAkB;AACrC,SAASC,QAAQ,EAAEC,cAAc,QAAQ,mBAAmB;AAC5D,SAASC,WAAW,EAAEC,aAAa,EAAEC,OAAO,QAAQ,YAAY;AAChE;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,IAAI,EAAE;EAClC,IAAI;IACA,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;IAC7B,IAAIC,IAAI,CAACG,OAAO,EAAE;MACd,OAAO,IAAI;IACf;EACJ,CAAC,CACD,OAAOC,KAAK,EAAE,CAAE;EAChB,OAAO,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACN,IAAI,EAAEO,SAAS,EAAE;EAClD,MAAMN,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;EAC7B,MAAMQ,QAAQ,GAAGZ,WAAW,CAACW,SAAS,CAAC;EACvC;EACA,MAAME,OAAO,GAAGlB,UAAU,CAACO,OAAO,CAACG,IAAI,EAAE,iBAAiB,CAAC,CAAC;EAC5D;EACA,MAAMG,OAAO,GAAGP,aAAa,CAACC,OAAO,CAACG,IAAI,EAAE,iBAAiB,CAAC,CAAC;EAC/DN,cAAc,CAACS,OAAO,IAAKA,OAAO,CAACM,MAAM,GAAG,EAAE,KAAM,CAAC,EAAE,iBAAiB,EAAE,MAAM,EAAEV,IAAI,CAAC;EACvF,MAAMW,GAAG,GAAGjB,QAAQ,CAACF,MAAM,CAACgB,QAAQ,EAAEA,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC,CAACI,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACjF,MAAMC,EAAE,GAAGT,OAAO,CAACQ,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAC/B,MAAME,aAAa,GAAGV,OAAO,CAACQ,KAAK,CAAC,EAAE,CAAC;EACvC;EACA,MAAMG,MAAM,GAAG,IAAI1B,GAAG,CAACsB,GAAG,EAAEE,EAAE,CAAC;EAC/B,MAAMG,IAAI,GAAG1B,UAAU,CAACI,QAAQ,CAACqB,MAAM,CAACE,OAAO,CAACH,aAAa,CAAC,CAAC,CAAC;EAChE;EACA,IAAII,OAAO,GAAG,EAAE;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACN,MAAM,EAAES,CAAC,EAAE,EAAE;IAClCD,OAAO,IAAIE,MAAM,CAACC,YAAY,CAACL,IAAI,CAACG,CAAC,CAAC,CAAC;EAC3C;EACA,OAAO;IAAEV,OAAO;IAAEa,UAAU,EAAE7B,EAAE,CAACyB,OAAO;EAAE,CAAC;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}