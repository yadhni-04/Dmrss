{"ast":null,"code":"//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n  let result = value.toString(16);\n  while (result.length < 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length,\n      offset\n    });\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n    buffer: data,\n    length: 0,\n    offset: 1\n  });\n  const checkOffset = offset => {\n    assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: data.length,\n      offset\n    });\n  };\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    checkOffset(offset + 1 + length);\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    checkOffset(offset + 1 + length);\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlifyByte(data[offset])\n  };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n  const data = getBytes(_data, \"data\");\n  const decoded = _decode(data, 0);\n  assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n  return decoded.result;\n}","map":{"version":3,"names":["hexlify","assert","assertArgument","getBytes","hexlifyByte","value","result","toString","length","unarrayifyInteger","data","offset","i","_decodeChildren","childOffset","decoded","_decode","push","consumed","buffer","checkOffset","lengthLength","slice","decodeRlp","_data"],"sources":["/Users/yadhnikharkar/Desktop/dmrs-mvp/frontend/node_modules/ethers/lib.esm/utils/rlp-decode.js"],"sourcesContent":["//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}